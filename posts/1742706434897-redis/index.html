<!DOCTYPE html>
<html lang="en" dir="ltr" class="scroll-smooth" data-default-appearance="dark"
  data-auto-appearance="true"><head>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="en" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title>redis &middot; Blog homepage</title>
  <meta name="title" content="redis &middot; Blog homepage" />
  
  <meta name="description" content="a description" />
  <meta name="keywords" content="example, tag, " />
  
  
  <link rel="canonical" href="https://shanymxc.github.io/posts/1742706434897-redis/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.1c9cd0d1ebaf117272b5c4f6bd49878475cb210d5e0da4f061632d779f5bb46851881c187e6e634dba5071c4e3d80e7d5cec1dd80443b2fa68acd358f9eda881.css"
    integrity="sha512-HJzQ0euvEXJytcT2vUmHhHXLIQ1eDaTwYWMtd59btGhRiBwYfm5jTbpQccTj2A59XOwd2ARDsvporNNY&#43;e2ogQ==" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.b6411b5d4cd56c0068d34c4acbce043846adad56b824e3d486a06d3459aed2eb7f7413874b7871cc2c822c8c8834cbed944022918bcc8cca710a962167c36d32.js"
    integrity="sha512-tkEbXUzVbABo00xKy84EOEatrVa4JOPUhqBtNFmu0ut/dBOHS3hxzCyCLIyINMvtlEAikYvMjMpxCpYhZ8NtMg==" data-copy="" data-copied=""></script>
  
  
  
  <script src="/lib/zoom/zoom.min.37d2094687372da3f7343a221a470f6b8806f7891aa46a5a03966af7f0ebd38b9fe536cb154e6ad28f006d184b294525a7c4054b6bbb4be62d8b453b42db99bd.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S&#43;Yti0U7QtuZvQ=="></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  
  <meta property="og:url" content="https://shanymxc.github.io/posts/1742706434897-redis/">
  <meta property="og:site_name" content="Blog homepage">
  <meta property="og:title" content="redis">
  <meta property="og:description" content="a description">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-23T00:00:00+00:00">
    <meta property="article:tag" content="Example">
    <meta property="article:tag" content="Tag">
    <meta property="og:image" content="https://shanymxc.github.io/posts/1742706434897-redis/featured.png">

  
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://shanymxc.github.io/posts/1742706434897-redis/featured.png">
  <meta name="twitter:title" content="redis">
  <meta name="twitter:description" content="a description">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "redis",
    "headline": "redis",
    "description": "a description",
    
    "inLanguage": "en",
    "url" : "https:\/\/shanymxc.github.io\/posts\/1742706434897-redis\/",
    "author" : {
      "@type": "Person",
      "name": "山有木兮"
    },
    "copyrightYear": "2025",
    "dateCreated": "2025-03-23T00:00:00\u002b00:00",
    "datePublished": "2025-03-23T00:00:00\u002b00:00",
    
    "dateModified": "2025-03-23T00:00:00\u002b00:00",
    
    "keywords": ["example","tag"],
    
    "mainEntityOfPage": "true",
    "wordCount": "4098"
  }]
  </script>


  
  
  <meta name="author" content="山有木兮" />
  
  
  
  <link href="mailto:%20mvz09630521@126.com" rel="me" />
  
  
  <link href="https://github.com/shanymxc" rel="me" />
  
  
  <link href="https://www.google.com/" rel="me" />
  
  
  <link href="https://steamcommunity.com/profiles/76561199164522002" rel="me" />
  
  
  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>






















  
  



  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a>
  </div>
  
  
  <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">Blog homepage</a>
            

        </nav>
        <nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12">

            
            
            
  <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="Posts">
        Posts
    </p>
</a>



            
            
  <a href=""  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        
    </p>
</a>



            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class=" flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 md:hidden">

        <label id="menu-button" class="block">
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li id="menu-close-button">
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                    
  <li class="mt-1">
    <a href="/posts/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="Posts">
            Posts
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href=""  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            
        </p>
    </a>
</li>




                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden">
  
  
    
  
    
  
  <li class="inline hidden">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/"
      >Blog homepage</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="inline ">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/posts/"
      >Posts</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  <li class="inline hidden">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/posts/1742706434897-redis/"
      >redis</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

</ol>


    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      redis
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  











  



<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="2025-03-23T00:00:00&#43;00:00">23 March 2025</time><span class="px-2 text-primary-500">&middot;</span><span>4098 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">20 mins</span><span class="px-2 text-primary-500">&middot;</span>


<script type="text/javascript" src="/js/zen-mode.min.eea5245cf9244ecbdf2c150d1c8833226c1541cadf6e98f63a7c9192b1a3676df2c3ec603b14f4cfaaa53971fd9d8955640c0f405bf3de2b43ee7a5fb29ae721.js" integrity="sha512-7qUkXPkkTsvfLBUNHIgzImwVQcrfbpj2OnyRkrGjZ23yw&#43;xgOxT0z6qlOXH9nYlVZAwPQFvz3itD7npfsprnIQ=="></script>

<span class="mb-[2px]">
    <span id="zen-mode-button"
          class="text-lg hover:text-primary-500"
          title="Enable zen mode"
          data-title-i18n-disable="Enable zen mode"
          data-title-i18n-enable="Disable zen mode">
        <span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50px" height="50px">
    <path fill="currentColor" d="M 12.980469 4 C 9.1204688 4 5.9804688 7.14 5.9804688 11 L 6 26 L 9.9804688 26 L 9.9804688 11 C 9.9804688 9.35 11.320469 8 12.980469 8 L 40.019531 8 C 41.679531 8 43.019531 9.35 43.019531 11 L 43.019531 39 C 43.019531 40.65 41.679531 42 40.019531 42 L 29 42 C 29 43.54 28.420938 44.94 27.460938 46 L 40.019531 46 C 43.879531 46 47.019531 42.86 47.019531 39 L 47.019531 11 C 47.019531 7.14 43.879531 4 40.019531 4 L 12.980469 4 z M 7 28 C 4.794 28 3 29.794 3 32 L 3 42 C 3 44.206 4.794 46 7 46 L 23 46 C 25.206 46 27 44.206 27 42 L 27 32 C 27 29.794 25.206 28 23 28 L 7 28 z M 7 32 L 23 32 L 23.001953 42 L 7 42 L 7 32 z"/>
</svg>
  </span>

</span>
    </span>
</span>
  

  
  
</div>





<div class="flex flex-row flex-wrap items-center">
  
  
  
  
  
  
  
  
  
  
  
  
  <span style="margin-top:0.5rem" class="mr-2" onclick="window.open(&#34;/tags/example/&#34;,'_self');return false;">
    <span class="flex" style="cursor: pointer;">
  <span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">
    Example
  </span>
</span>
  </span>
  
  <span style="margin-top:0.5rem" class="mr-2" onclick="window.open(&#34;/tags/tag/&#34;,'_self');return false;">
    <span class="flex" style="cursor: pointer;">
  <span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">
    Tag
  </span>
</span>
  </span>
  
  
  
  
</div>




    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
    
    
      
    
    
      
        
      
      <img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width="96" height="96"
      alt="山有木兮" src="/../assets/profilePhoto_hu_b4a36b85e5a62ffb.jpg" />
    
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      Author
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      山有木兮
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">But thy eternal summer shall not fade.</div>
    
    <div class="text-2xl sm:text-lg">
  <div class="flex flex-wrap text-neutral-400 dark:text-neutral-500">
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="mailto:%20mvz09630521@126.com"
          target="_blank"
          aria-label="Email"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1c-27.64 140.9 68.65 266.2 199.1 285.1c19.01 2.888 36.17-12.26 36.17-31.49l.0001-.6631c0-15.74-11.44-28.88-26.84-31.24c-84.35-12.98-149.2-86.13-149.2-174.2c0-102.9 88.61-185.5 193.4-175.4c91.54 8.869 158.6 91.25 158.6 183.2l0 16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98 .0036c-7.299 0-13.2 4.992-15.12 11.68c-24.85-12.15-54.24-16.38-86.06-5.106c-38.75 13.73-68.12 48.91-73.72 89.64c-9.483 69.01 43.81 128 110.9 128c26.44 0 50.43-9.544 69.59-24.88c24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3C495.1 107.1 361.2-9.332 207.8 20.73zM239.1 304.3c-26.47 0-48-21.56-48-48.05s21.53-48.05 48-48.05s48 21.56 48 48.05S266.5 304.3 239.1 304.3z"/></svg>

  </span>

</span></a
        >
      
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://github.com/shanymxc"
          target="_blank"
          aria-label="Github"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>

</span></a
        >
      
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://www.google.com/"
          target="_blank"
          aria-label="Google"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 512"><path fill="currentColor" d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"/></svg>

  </span>

</span></a
        >
      
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://steamcommunity.com/profiles/76561199164522002"
          target="_blank"
          aria-label="Steam"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M496 256c0 137-111.2 248-248.4 248-113.8 0-209.6-76.3-239-180.4l95.2 39.3c6.4 32.1 34.9 56.4 68.9 56.4 39.2 0 71.9-32.4 70.2-73.5l84.5-60.2c52.1 1.3 95.8-40.9 95.8-93.5 0-51.6-42-93.5-93.7-93.5s-93.7 42-93.7 93.5v1.2L176.6 279c-15.5-.9-30.7 3.4-43.5 12.1L0 236.1C10.2 108.4 117.1 8 247.6 8 384.8 8 496 119 496 256zM155.7 384.3l-30.5-12.6a52.79 52.79 0 0 0 27.2 25.8c26.9 11.2 57.8-1.6 69-28.4 5.4-13 5.5-27.3.1-40.3-5.4-13-15.5-23.2-28.5-28.6-12.9-5.4-26.7-5.2-38.9-.6l31.5 13c19.8 8.2 29.2 30.9 20.9 50.7-8.3 19.9-31 29.2-50.8 21zm173.8-129.9c-34.4 0-62.4-28-62.4-62.3s28-62.3 62.4-62.3 62.4 28 62.4 62.3-27.9 62.3-62.4 62.3zm.1-15.6c25.9 0 46.9-21 46.9-46.8 0-25.9-21-46.8-46.9-46.8s-46.9 21-46.9 46.8c.1 25.8 21.1 46.8 46.9 46.8z"/></svg>

  </span>

</span></a
        >
      
    
  </div>

</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
     <div
      class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8">
      <div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10">

         <details open id="TOCView"
  class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#11-双写一致性">1.1 双写一致性</a>
      <ul>
        <li><a href="#111-概念">1.1.1 概念</a></li>
        <li><a href="#112-解决方案">1.1.2 解决方案</a>
          <ul>
            <li><a href="#1121-使用分布式锁">1.1.2.1 使用分布式锁</a></li>
            <li><a href="#1122-延迟双删">1.1.2.2 延迟双删</a></li>
            <li><a href="#1123-异步同步">1.1.2.3 异步同步</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#21-redis基础">2.1 Redis基础</a>
      <ul>
        <li><a href="#211-什么是redis">2.1.1 什么是Redis?</a></li>
        <li><a href="#212-redis为什么这么快">2.1.2 Redis为什么这么快？</a></li>
        <li><a href="#213-其他分布式缓存方案">2.1.3 其他分布式缓存方案</a></li>
        <li><a href="#214-说一下redis和memcached的区别和共同点">2.1.4 说一下Redis和Memcached的区别和共同点</a></li>
        <li><a href="#215-为什么要用redis">2.1.5 为什么要用redis?</a></li>
        <li><a href="#217-什么是redis-module有什么用">2.1.7 什么是Redis Module？有什么用？</a></li>
      </ul>
    </li>
    <li><a href="#22-redis应用">2.2 Redis应用</a>
      <ul>
        <li><a href="#221-redis除了做缓存还能做什么">2.2.1 Redis除了做缓存，还能做什么？</a></li>
        <li><a href="#223-redis可以做消息队列吗">2.2.3 Redis可以做消息队列吗？</a></li>
        <li><a href="#224-redis可以做搜索引擎吗">2.2.4 Redis可以做搜索引擎吗？</a></li>
        <li><a href="#225-如何基于redis实现延时任务">2.2.5 如何基于Redis实现延时任务？</a></li>
      </ul>
    </li>
    <li><a href="#23-redis数据类型">2.3 Redis数据类型</a>
      <ul>
        <li><a href="#231-redis常用的数据类型">2.3.1 Redis常用的数据类型</a></li>
        <li><a href="#232-string的应用场景">2.3.2 String的应用场景</a></li>
        <li><a href="#233-string还是hash存储对象数据更好">2.3.3 String还是Hash存储对象数据更好</a></li>
        <li><a href="#234-string的底层实现">2.3.4 String的底层实现</a></li>
        <li><a href="#236-购物车信息用string还是hash存储更好">2.3.6 购物车信息用String还是Hash存储更好</a></li>
        <li><a href="#237-使用redis实现一个排行榜">2.3.7 使用Redis实现一个排行榜</a></li>
        <li><a href="#238-redis的有序集合底层为什么要用跳表而不用平衡树红黑树或者b树">2.3.8 Redis的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者B+树？</a></li>
        <li><a href="#239-set的应用场景">2.3.9 Set的应用场景</a></li>
        <li><a href="#2310-使用set实现抽奖系统">2.3.10 使用Set实现抽奖系统</a></li>
        <li><a href="#2311-使用bitmap统计活跃用户">2.3.11 使用Bitmap统计活跃用户</a></li>
        <li><a href="#2312-使用hyperloglog统计页面uv怎么做">2.3.12 使用HyperLogLog统计页面UV怎么做？</a></li>
      </ul>
    </li>
    <li><a href="#25-redis线程模型">2.5 Redis线程模型</a>
      <ul>
        <li><a href="#251-redis单线程模型">2.5.1 Redis单线程模型</a></li>
        <li><a href="#252-redis60-之前为什么不使用多线程">2.5.2 Redis6.0 之前为什么不使用多线程</a></li>
        <li><a href="#253-redis60-之后为何引入了多线程">2.5.3 Redis6.0 之后为何引入了多线程</a></li>
        <li><a href="#254-redis后台线程">2.5.4 Redis后台线程</a></li>
      </ul>
    </li>
    <li><a href="#26-redis内存管理">2.6 Redis内存管理</a>
      <ul>
        <li><a href="#261-redis-给缓存数据设置过期时间有什么用">2.6.1 Redis 给缓存数据设置过期时间有什么用</a></li>
        <li><a href="#262-redis是如何判断数据是否过期的">2.6.2 Redis是如何判断数据是否过期的</a></li>
        <li><a href="#263-redis过期key删除策略">2.6.3 Redis过期key删除策略</a></li>
        <li><a href="#264-大量key集中过期怎么办">2.6.4 大量key集中过期怎么办</a></li>
        <li><a href="#265-redis内存淘汰策略">2.6.5 Redis内存淘汰策略</a></li>
      </ul>
    </li>
    <li><a href="#27-redis事务">2.7 Redis事务</a>
      <ul>
        <li><a href="#271-什么是redis事务">2.7.1 什么是Redis事务？</a></li>
        <li><a href="#272-如何使用redis事务">2.7.2 如何使用Redis事务？</a></li>
        <li><a href="#273-redis事务支持原子性吗">2.7.3 Redis事务支持原子性吗？</a></li>
        <li><a href="#274-redis事务支持持久性吗">2.7.4 Redis事务支持持久性吗？</a></li>
        <li><a href="#275-如何解决redis事务的缺陷">2.7.5 如何解决Redis事务的缺陷</a></li>
      </ul>
    </li>
    <li><a href="#28-redis性能优化">2.8 Redis性能优化</a>
      <ul>
        <li><a href="#281-使用批量操作减少网络传输">2.8.1 使用批量操作减少网络传输</a>
          <ul>
            <li><a href="#2811-原生批量操作命令">2.8.1.1 原生批量操作命令</a></li>
            <li><a href="#2812-pipline">2.8.1.2 pipline</a></li>
            <li><a href="#2813-lua脚本">2.8.1.3 lua脚本</a></li>
          </ul>
        </li>
        <li><a href="#282-大量key集中过期问题">2.8.2 大量key集中过期问题</a></li>
        <li><a href="#283-redis-bigkey大-key">2.8.3 Redis bigkey（大 Key）</a>
          <ul>
            <li><a href="#2831-什么是bigkey">2.8.3.1 什么是bigkey？</a></li>
            <li><a href="#2832-bigkey是怎么产生的有什么危害">2.8.3.2 bigkey是怎么产生的？有什么危害？</a></li>
            <li><a href="#2833-如何发现bugkey">2.8.3.3 如何发现bugkey?</a></li>
            <li><a href="#2834-如何处理bigkey">2.8.3.4 如何处理bigkey？</a></li>
          </ul>
        </li>
        <li><a href="#284-redis-hotkey热-key">2.8.4 Redis hotkey（热 Key）</a>
          <ul>
            <li><a href="#2841-什么是hotkey">2.8.4.1 什么是hotkey？</a></li>
            <li><a href="#2842-hotkey有什么危害">2.8.4.2 hotkey有什么危害</a></li>
            <li><a href="#2843-如何发现hotkey">2.8.4.3 如何发现hotkey？</a></li>
            <li><a href="#2844-如何解决hotkey">2.8.4.4 如何解决hotkey？</a></li>
          </ul>
        </li>
        <li><a href="#285-查询慢命令">2.8.5 查询慢命令</a>
          <ul>
            <li><a href="#2851-为什么会有查询慢命令">2.8.5.1 为什么会有查询慢命令</a></li>
            <li><a href="#2852-如何找到慢查询命令">2.8.5.2 如何找到慢查询命令</a></li>
          </ul>
        </li>
        <li><a href="#286-redis-内存碎片">2.8.6 Redis 内存碎片</a></li>
      </ul>
    </li>
    <li><a href="#29-redis生产问题">2.9 Redis生产问题</a>
      <ul>
        <li><a href="#291-缓存穿透">2.9.1 缓存穿透</a>
          <ul>
            <li><a href="#2911-什么是缓存穿透">2.9.1.1 什么是缓存穿透？</a></li>
            <li><a href="#2912-有哪些解决方法">2.9.1.2 有哪些解决方法？</a></li>
          </ul>
        </li>
        <li><a href="#292-缓存击穿">2.9.2 缓存击穿</a>
          <ul>
            <li><a href="#2921-什么是缓存击穿">2.9.2.1 什么是缓存击穿？</a></li>
            <li><a href="#2922-有哪些解决办法">2.9.2.2 有哪些解决办法？</a></li>
            <li><a href="#2923-缓存穿透和缓存击穿有什么区别">2.9.2.3 缓存穿透和缓存击穿有什么区别</a></li>
          </ul>
        </li>
        <li><a href="#293-缓存雪崩">2.9.3 缓存雪崩</a>
          <ul>
            <li><a href="#2931-什么是缓存雪崩">2.9.3.1 什么是缓存雪崩</a></li>
            <li><a href="#2932-有哪些解决办法">2.9.3.2 有哪些解决办法</a></li>
            <li><a href="#2933-缓存预热如何实现">2.9.3.3 缓存预热如何实现</a></li>
            <li><a href="#2934-缓存雪崩和缓存击穿有什么区别">2.9.3.4 缓存雪崩和缓存击穿有什么区别</a></li>
          </ul>
        </li>
        <li><a href="#294-如何保证缓存和数据库数据的一致性">2.9.4 如何保证缓存和数据库数据的一致性</a></li>
        <li><a href="#295-哪些情况可能会导致redis阻塞">2.9.5 哪些情况可能会导致Redis阻塞</a></li>
      </ul>
    </li>
    <li><a href="#210-redis集群">2.10 Redis集群</a></li>
    <li><a href="#211-redis使用规范">2.11 Redis使用规范</a></li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    Table of Contents
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#11-双写一致性">1.1 双写一致性</a>
      <ul>
        <li><a href="#111-概念">1.1.1 概念</a></li>
        <li><a href="#112-解决方案">1.1.2 解决方案</a>
          <ul>
            <li><a href="#1121-使用分布式锁">1.1.2.1 使用分布式锁</a></li>
            <li><a href="#1122-延迟双删">1.1.2.2 延迟双删</a></li>
            <li><a href="#1123-异步同步">1.1.2.3 异步同步</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#21-redis基础">2.1 Redis基础</a>
      <ul>
        <li><a href="#211-什么是redis">2.1.1 什么是Redis?</a></li>
        <li><a href="#212-redis为什么这么快">2.1.2 Redis为什么这么快？</a></li>
        <li><a href="#213-其他分布式缓存方案">2.1.3 其他分布式缓存方案</a></li>
        <li><a href="#214-说一下redis和memcached的区别和共同点">2.1.4 说一下Redis和Memcached的区别和共同点</a></li>
        <li><a href="#215-为什么要用redis">2.1.5 为什么要用redis?</a></li>
        <li><a href="#217-什么是redis-module有什么用">2.1.7 什么是Redis Module？有什么用？</a></li>
      </ul>
    </li>
    <li><a href="#22-redis应用">2.2 Redis应用</a>
      <ul>
        <li><a href="#221-redis除了做缓存还能做什么">2.2.1 Redis除了做缓存，还能做什么？</a></li>
        <li><a href="#223-redis可以做消息队列吗">2.2.3 Redis可以做消息队列吗？</a></li>
        <li><a href="#224-redis可以做搜索引擎吗">2.2.4 Redis可以做搜索引擎吗？</a></li>
        <li><a href="#225-如何基于redis实现延时任务">2.2.5 如何基于Redis实现延时任务？</a></li>
      </ul>
    </li>
    <li><a href="#23-redis数据类型">2.3 Redis数据类型</a>
      <ul>
        <li><a href="#231-redis常用的数据类型">2.3.1 Redis常用的数据类型</a></li>
        <li><a href="#232-string的应用场景">2.3.2 String的应用场景</a></li>
        <li><a href="#233-string还是hash存储对象数据更好">2.3.3 String还是Hash存储对象数据更好</a></li>
        <li><a href="#234-string的底层实现">2.3.4 String的底层实现</a></li>
        <li><a href="#236-购物车信息用string还是hash存储更好">2.3.6 购物车信息用String还是Hash存储更好</a></li>
        <li><a href="#237-使用redis实现一个排行榜">2.3.7 使用Redis实现一个排行榜</a></li>
        <li><a href="#238-redis的有序集合底层为什么要用跳表而不用平衡树红黑树或者b树">2.3.8 Redis的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者B+树？</a></li>
        <li><a href="#239-set的应用场景">2.3.9 Set的应用场景</a></li>
        <li><a href="#2310-使用set实现抽奖系统">2.3.10 使用Set实现抽奖系统</a></li>
        <li><a href="#2311-使用bitmap统计活跃用户">2.3.11 使用Bitmap统计活跃用户</a></li>
        <li><a href="#2312-使用hyperloglog统计页面uv怎么做">2.3.12 使用HyperLogLog统计页面UV怎么做？</a></li>
      </ul>
    </li>
    <li><a href="#25-redis线程模型">2.5 Redis线程模型</a>
      <ul>
        <li><a href="#251-redis单线程模型">2.5.1 Redis单线程模型</a></li>
        <li><a href="#252-redis60-之前为什么不使用多线程">2.5.2 Redis6.0 之前为什么不使用多线程</a></li>
        <li><a href="#253-redis60-之后为何引入了多线程">2.5.3 Redis6.0 之后为何引入了多线程</a></li>
        <li><a href="#254-redis后台线程">2.5.4 Redis后台线程</a></li>
      </ul>
    </li>
    <li><a href="#26-redis内存管理">2.6 Redis内存管理</a>
      <ul>
        <li><a href="#261-redis-给缓存数据设置过期时间有什么用">2.6.1 Redis 给缓存数据设置过期时间有什么用</a></li>
        <li><a href="#262-redis是如何判断数据是否过期的">2.6.2 Redis是如何判断数据是否过期的</a></li>
        <li><a href="#263-redis过期key删除策略">2.6.3 Redis过期key删除策略</a></li>
        <li><a href="#264-大量key集中过期怎么办">2.6.4 大量key集中过期怎么办</a></li>
        <li><a href="#265-redis内存淘汰策略">2.6.5 Redis内存淘汰策略</a></li>
      </ul>
    </li>
    <li><a href="#27-redis事务">2.7 Redis事务</a>
      <ul>
        <li><a href="#271-什么是redis事务">2.7.1 什么是Redis事务？</a></li>
        <li><a href="#272-如何使用redis事务">2.7.2 如何使用Redis事务？</a></li>
        <li><a href="#273-redis事务支持原子性吗">2.7.3 Redis事务支持原子性吗？</a></li>
        <li><a href="#274-redis事务支持持久性吗">2.7.4 Redis事务支持持久性吗？</a></li>
        <li><a href="#275-如何解决redis事务的缺陷">2.7.5 如何解决Redis事务的缺陷</a></li>
      </ul>
    </li>
    <li><a href="#28-redis性能优化">2.8 Redis性能优化</a>
      <ul>
        <li><a href="#281-使用批量操作减少网络传输">2.8.1 使用批量操作减少网络传输</a>
          <ul>
            <li><a href="#2811-原生批量操作命令">2.8.1.1 原生批量操作命令</a></li>
            <li><a href="#2812-pipline">2.8.1.2 pipline</a></li>
            <li><a href="#2813-lua脚本">2.8.1.3 lua脚本</a></li>
          </ul>
        </li>
        <li><a href="#282-大量key集中过期问题">2.8.2 大量key集中过期问题</a></li>
        <li><a href="#283-redis-bigkey大-key">2.8.3 Redis bigkey（大 Key）</a>
          <ul>
            <li><a href="#2831-什么是bigkey">2.8.3.1 什么是bigkey？</a></li>
            <li><a href="#2832-bigkey是怎么产生的有什么危害">2.8.3.2 bigkey是怎么产生的？有什么危害？</a></li>
            <li><a href="#2833-如何发现bugkey">2.8.3.3 如何发现bugkey?</a></li>
            <li><a href="#2834-如何处理bigkey">2.8.3.4 如何处理bigkey？</a></li>
          </ul>
        </li>
        <li><a href="#284-redis-hotkey热-key">2.8.4 Redis hotkey（热 Key）</a>
          <ul>
            <li><a href="#2841-什么是hotkey">2.8.4.1 什么是hotkey？</a></li>
            <li><a href="#2842-hotkey有什么危害">2.8.4.2 hotkey有什么危害</a></li>
            <li><a href="#2843-如何发现hotkey">2.8.4.3 如何发现hotkey？</a></li>
            <li><a href="#2844-如何解决hotkey">2.8.4.4 如何解决hotkey？</a></li>
          </ul>
        </li>
        <li><a href="#285-查询慢命令">2.8.5 查询慢命令</a>
          <ul>
            <li><a href="#2851-为什么会有查询慢命令">2.8.5.1 为什么会有查询慢命令</a></li>
            <li><a href="#2852-如何找到慢查询命令">2.8.5.2 如何找到慢查询命令</a></li>
          </ul>
        </li>
        <li><a href="#286-redis-内存碎片">2.8.6 Redis 内存碎片</a></li>
      </ul>
    </li>
    <li><a href="#29-redis生产问题">2.9 Redis生产问题</a>
      <ul>
        <li><a href="#291-缓存穿透">2.9.1 缓存穿透</a>
          <ul>
            <li><a href="#2911-什么是缓存穿透">2.9.1.1 什么是缓存穿透？</a></li>
            <li><a href="#2912-有哪些解决方法">2.9.1.2 有哪些解决方法？</a></li>
          </ul>
        </li>
        <li><a href="#292-缓存击穿">2.9.2 缓存击穿</a>
          <ul>
            <li><a href="#2921-什么是缓存击穿">2.9.2.1 什么是缓存击穿？</a></li>
            <li><a href="#2922-有哪些解决办法">2.9.2.2 有哪些解决办法？</a></li>
            <li><a href="#2923-缓存穿透和缓存击穿有什么区别">2.9.2.3 缓存穿透和缓存击穿有什么区别</a></li>
          </ul>
        </li>
        <li><a href="#293-缓存雪崩">2.9.3 缓存雪崩</a>
          <ul>
            <li><a href="#2931-什么是缓存雪崩">2.9.3.1 什么是缓存雪崩</a></li>
            <li><a href="#2932-有哪些解决办法">2.9.3.2 有哪些解决办法</a></li>
            <li><a href="#2933-缓存预热如何实现">2.9.3.3 缓存预热如何实现</a></li>
            <li><a href="#2934-缓存雪崩和缓存击穿有什么区别">2.9.3.4 缓存雪崩和缓存击穿有什么区别</a></li>
          </ul>
        </li>
        <li><a href="#294-如何保证缓存和数据库数据的一致性">2.9.4 如何保证缓存和数据库数据的一致性</a></li>
        <li><a href="#295-哪些情况可能会导致redis阻塞">2.9.5 哪些情况可能会导致Redis阻塞</a></li>
      </ul>
    </li>
    <li><a href="#210-redis集群">2.10 Redis集群</a></li>
    <li><a href="#211-redis使用规范">2.11 Redis使用规范</a></li>
  </ul>
</nav>
  </div>
</details>

<script>

  var margin = 200;
  var marginError = 50;

  (function () {
    var $window = $(window);
    var $toc = $('#TOCView');
    var tocHeight = $toc.height();

    function onResize() {
      var windowAndMarginHeight = $window.height() - margin;
      if(tocHeight >= windowAndMarginHeight) {
        $toc.css("overflow-y", "scroll")
        $toc.css("max-height", (windowAndMarginHeight + marginError) + "px")
      } else {
        $toc.css("overflow-y", "hidden")
        $toc.css("max-height", "9999999px")
      }
    }

    $window.on('resize', onResize);
    $(document).ready(onResize);
  })();



  (function () {
    var $toc = $('#TableOfContents');
    if ($toc.length > 0) {
      var $window = $(window);

      function onScroll() {
        var currentScroll = $window.scrollTop();
        var h = $('.anchor');
        var id = "";
        h.each(function (i, e) {
          e = $(e);
          if (e.offset().top - $(window).height()/3 <= currentScroll) {
            id = decodeURIComponent(e.attr('id'));
          }
        });
        var active = $toc.find('a.active');      
        if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

        active.each(function (i, e) {
          
            $(e).removeClass('active');
          
        });
        $toc.find('a[href="#' + id + '"]').addClass('active')
        $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
          $(e).children('a').parents('ul').show();          
        });
      }

      $window.on('scroll', onScroll);
      $(document).ready(function () {
        
        onScroll();
      });
    }
  })();


</script>
   </div>
      </div>
      

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h1 class="relative group">缓存基础 
    <div id="%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80" aria-label="Anchor">#</a>
    </span>        
    
</h1>


<h2 class="relative group">1.1 双写一致性 
    <div id="11-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#11-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">1.1.1 概念 
    <div id="111-%E6%A6%82%E5%BF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#111-%E6%A6%82%E5%BF%B5" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>缓存不一致问题是指当发生数据变更后该数据在数据库和缓存中是不一致的，此时查询缓存得到的并不是与数据库一致的数据。Redis的双写一致性，一般是基于两种场景，第一个是追求强一致性，第二个允许延迟一致（保证数据的最终一致性）</p>
<p>写数据库和写缓存导致不一致称为<strong>双写不一致</strong>，比如：先更新数据库成功了，更新缓存时失败了，最终导致不一致。</p>


<h3 class="relative group">1.1.2 解决方案 
    <div id="112-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#112-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">1.1.2.1 使用分布式锁 
    <div id="1121-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1121-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131510714.png" alt="image-20250323131510714" />
      
    </figure>
</p>
<p>流程：</p>
<ul>
<li>线程1申请分布式锁，拿到锁。此时其它线程无法获取同一把锁。</li>
<li>线程1写数据库，写缓存，操作完成释放锁。</li>
<li>线程2申请分布锁成功，写数据库，写缓存。</li>
<li>对双写的操作每个线程顺序执行。</li>
</ul>
<p>对操作异常问题仍需要解决：写数据库成功写缓存失败了，数据库需要回滚，此时就需要使用分布式事务组件。</p>
<p>使用<strong>分布式锁</strong>解决双写一致性不仅性能低下，而且复杂度也会增加。</p>


<h4 class="relative group">1.1.2.2 延迟双删 
    <div id="1122-%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1122-%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>既然双写操作存在不一致，我们把写缓存改为删除缓存呢？</p>
<p>先写数据库再删除缓存，如果删除缓存失败了缓存也就不一致了，那我们改为：先删除缓存再写数据库，如下图：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131531597.png" alt="image-20250323131531597" />
      
    </figure>
</p>
<p>执行流程：</p>
<ul>
<li>线程1删除缓存</li>
<li>线程2读缓存发现没有数据此时查询数据库拿到旧数据写入缓存</li>
<li>线程1写入数据库</li>
</ul>
<p>即使线程1删除缓存、写数据库操作后线程2再去查询缓存也可能存在问题，如下图：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131547095.png" alt="image-20250323131547095" />
      
    </figure>
</p>
<p>线程1向主数据库写，线程2向从数据库查询，流程如下：</p>
<ul>
<li>线程1删除缓存</li>
<li>线程1向主数据库写，数据向从数据库同步</li>
<li>线程2查询缓存没有数据，查询从数据库，得到旧数据</li>
<li>线程2将旧数据写入缓存</li>
</ul>
<p>解决上边的问题采用延迟双删：</p>
<p><strong>线程1先删除缓存，再写入主数据库，延迟一定时间再删除缓存。</strong></p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131605757.png" alt="image-20250323131605757" />
      
    </figure>
</p>
<p>上图线程1的动作简化为下图：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131620986.png" alt="image-20250323131620986" />
      
    </figure>
</p>
<p>延迟多长时间呢？</p>
<p>延迟主数据向从数据库同步的时间间隔，如果延迟时间设置不合理也会导致数据不一致。</p>
<p>延迟时间设置的不合理，可能会带来更多问题</p>
<ul>
<li>过短：脏数据</li>
<li>过长：更新失效不及时</li>
</ul>


<h4 class="relative group">1.1.2.3 异步同步 
    <div id="1123-%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#1123-%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>延迟双删的目的也是为了保证最终一致性，即允许缓存短暂不一致，最终保证一致性。</p>
<p>保证最终一致性的方案有很多，比如：通过<strong>MQ、Canal、定时任务</strong>都可以实现。</p>
<p>Canal是一个数据同步工具，读取MySQL的binlog日志拿到更新的数据，再通过MQ发送给异步同步程序，最终由异步同步程序写到redis。此方案适用于对数据实时性有一定要求的场景。</p>
<p><strong>通过Canal加MQ异步任务方式流程如下</strong>：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131634174.png" alt="image-20250323131634174" />
      
    </figure>
</p>
<p>流程如下：</p>
<ul>
<li>线程1写数据库</li>
<li>canal读取binlog日志，将数据变化日志写入mq</li>
<li>同步程序监听mq接收到数据变化的消息</li>
<li>同步程序解析消息内容写入redis，写入redis成功正常消费完成，消息从mq删除。</li>
</ul>
<p><strong>定时任务方式流程如下：</strong></p>
<p>专门启动一个数据同步任务定时读取数据同步到redis，此方式适用于对数据实时性要求不强更新不频繁的数据。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131647161.png" alt="image-20250323131647161" />
      
    </figure>
</p>
<p>线程1写入数据库（业务数据表，变化日志表）</p>
<p>同步程序读取数据库（变化日志表），根据变化日志内容写入redis，同步完成删除变化日志。</p>


<h1 class="relative group">Redis常见面试题 
    <div id="redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h1>


<h2 class="relative group">2.1 Redis基础 
    <div id="21-redis%E5%9F%BA%E7%A1%80" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#21-redis%E5%9F%BA%E7%A1%80" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.1.1 什么是Redis? 
    <div id="211-%E4%BB%80%E4%B9%88%E6%98%AFredis" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#211-%E4%BB%80%E4%B9%88%E6%98%AFredis" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>==<strong><a href="https://redis.io/" target="_blank">Redis</a> （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。</strong>==并且，<strong>Redis 存储的是 KV 键值对数据。</strong></p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131700116.png" alt="image-20250323131700116" />
      
    </figure>
</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/" target="_blank">在线 Redis 环境</a>（少部分命令无法使用）来实际体验 Redis。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131718359.png" alt="image-20250323131718359" />
      
    </figure>
</p>
<p>全世界有非常多的网站使用到了 Redis ，<a href="https://techstacks.io/" target="_blank">techstacks.io</a> 专门维护了一个<a href="https://techstacks.io/tech/redis" target="_blank">使用 Redis 的热门站点列表</a> ，感兴趣的话可以看看。</p>


<h3 class="relative group">2.1.2 Redis为什么这么快？ 
    <div id="212-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#212-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>
<ol>
<li>Redis 基于内存，内存的访问速度比磁盘快很多；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。</li>
<li>Redis 通信协议实现简单且解析高效。</li>
</ol>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131732621.png" alt="image-20250323131732621" />
      
    </figure>
</p>
<p>那既然都这么快了，为什么不直接用 Redis 当主数据库呢？主要是因为内存成本太高且 Redis 提供的数据持久化仍然有数据丢失的风险</p>


<h3 class="relative group">2.1.3 其他分布式缓存方案 
    <div id="213-%E5%85%B6%E4%BB%96%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#213-%E5%85%B6%E4%BB%96%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>如果面试中被问到这个问题的话，面试官主要想看看：</p>
<ol>
<li>你在选择 Redis 作为分布式缓存方案时，是否是经过严谨的调研和思考，还是只是因为 Redis 是当前的“热门”技术。</li>
<li>你在分布式缓存方向的技术广度。</li>
</ol>
<p>如果你了解其他方案，并且能解释为什么最终选择了 Redis（更进一步！），这会对你面试表现加分不少！</p>
<p>下面简单聊聊常见的分布式缓存技术选型。</p>
<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>有一些大厂也开源了类似于 Redis 的分布式高性能 KV 存储数据库，例如，腾讯开源的 <a href="https://github.com/Tencent/Tendis" target="_blank"><strong>Tendis</strong></a> 。Tendis 基于知名开源项目 <a href="https://github.com/facebook/rocksdb" target="_blank">RocksDB</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型。关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ" target="_blank">Redis vs Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>
<p>不过，从 Tendis 这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p>
<p>目前，比较业界认可的 Redis 替代品还是下面这两个开源分布式缓存（都是通过碰瓷 Redis 火的）：</p>
<ul>
<li><a href="https://github.com/dragonflydb/dragonfly" target="_blank">Dragonfly</a>（<em>/<em>ˈdræɡənflaɪ</em>/</em>）：一种针对现代应用程序负荷需求而构建的内存数据库，完全兼容 Redis 和 Memcached 的 API，迁移时无需修改任何代码，号称全世界最快的内存数据库。</li>
<li><a href="https://github.com/Snapchat/KeyDB" target="_blank">KeyDB</a>： Redis 的一个高性能分支，专注于多线程、内存效率和高吞吐量。</li>
</ul>
<p>不过，个人还是建议分布式缓存首选 Redis ，毕竟经过这么多年的生考验，生态也这么优秀，资料也很全面！</p>


<h3 class="relative group">2.1.4 说一下Redis和Memcached的区别和共同点 
    <div id="214-%E8%AF%B4%E4%B8%80%E4%B8%8Bredis%E5%92%8Cmemcached%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#214-%E8%AF%B4%E4%B8%80%E4%B8%8Bredis%E5%92%8Cmemcached%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>数据类型</strong>：Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>数据持久化</strong>：**Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 把数据全部存在内存之中。**也就是说，Redis 有灾难恢复机制而 Memcached 没有。</li>
<li><strong>集群模式支持</strong>：Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 自 3.0 版本起是原生支持集群模式的。</li>
<li><strong>线程模型</strong>：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）</li>
<li><strong>特性支持</strong>：Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</li>
<li><strong>过期数据删除</strong>：Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>


<h3 class="relative group">2.1.5 为什么要用redis? 
    <div id="215-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8redis" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#215-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8redis" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>1、访问速度更快</strong></p>
<p>传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。</p>
<p><strong>2、高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<p><strong>3、功能全面</strong></p>
<p>Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</p>


<h3 class="relative group">2.1.7 什么是Redis Module？有什么用？ 
    <div id="217-%E4%BB%80%E4%B9%88%E6%98%AFredis-module%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#217-%E4%BB%80%E4%B9%88%E6%98%AFredis-module%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so 文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，值得借鉴学习！</p>
<p>我们每个人都可以基于 Redis 去定制化开发自己的 Module，比如实现搜索引擎功能、自定义分布式锁和分布式限流。</p>
<p>目前，被 Redis 官方推荐的 Module 有：</p>
<ul>
<li><a href="https://github.com/RediSearch/RediSearch" target="_blank">RediSearch</a>：用于实现搜索引擎的模块。</li>
<li><a href="https://github.com/RedisJSON/RedisJSON" target="_blank">RedisJSON</a>：用于处理 JSON 数据的模块。</li>
<li><a href="https://github.com/RedisGraph/RedisGraph" target="_blank">RedisGraph</a>：用于实现图形数据库的模块。</li>
<li><a href="https://github.com/RedisTimeSeries/RedisTimeSeries" target="_blank">RedisTimeSeries</a>：用于处理时间序列数据的模块。</li>
<li><a href="https://github.com/RedisBloom/RedisBloom" target="_blank">RedisBloom</a>：用于实现布隆过滤器的模块。</li>
<li><a href="https://github.com/RedisAI/RedisAI" target="_blank">RedisAI</a>：用于执行深度学习/机器学习模型并管理其数据的模块。</li>
<li><a href="https://github.com/brandur/redis-cell" target="_blank">RedisCell</a>：用于实现分布式限流的模块。</li>
<li>……</li>
</ul>
<p>关于 Redis 模块的详细介绍，可以查看官方文档：https://redis.io/modules。</p>


<h2 class="relative group">2.2 Redis应用 
    <div id="22-redis%E5%BA%94%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#22-redis%E5%BA%94%E7%94%A8" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.2.1 Redis除了做缓存，还能做什么？ 
    <div id="221-redis%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#221-redis%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<ul>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁 。</li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。如果不想自己写 Lua 脚本的话，也可以直接利用 Redisson 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>
<li><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</li>
<li>……</li>
</ul>


<h3 class="relative group">2.2.3 Redis可以做消息队列吗？ 
    <div id="223-redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#223-redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<blockquote>
<p>实际项目中使用 Redis 来做消息队列的非常少，毕竟有更成熟的消息队列中间件可以用。</p></blockquote>
<p>先说结论：<strong>可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</strong></p>
<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 生产者生产消息</span>
</span></span><span class="line"><span class="cl">&gt; RPUSH myList msg1 msg2
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl">&gt; RPUSH myList msg3
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 消费者消费消息</span>
</span></span><span class="line"><span class="cl">&gt; LPOP myList
</span></span><span class="line"><span class="cl"><span class="s2">&#34;msg1&#34;</span>
</span></span></code></pre></div><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Blocking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后再返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 超时时间为 10s</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 如果有数据立刻返回，否则最多等待10秒</span>
</span></span><span class="line"><span class="cl">&gt; BRPOP myList <span class="m">10</span>
</span></span><span class="line"><span class="cl">null
</span></span></code></pre></div><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<p><strong>Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131749570.png" alt="image-20250323131749570" />
      
    </figure>
</p>
<p>Redis 发布订阅 (pub/sub) 功能</p>
<p>pub/sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131804006.png" alt="image-20250323131804006" />
      
    </figure>
</p>
<p>pub/sub 实现消息队列演示</p>
<p>pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费（借鉴了 Kafka 消费者组的概念）</li>
<li>消息持久化（ RDB 和 AOF）</li>
<li>ACK 机制（通过确认机制来告知已经成功处理了消息）</li>
<li>阻塞式获取消息</li>
</ul>
<p><code>Stream</code> 的结构如下：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131815258.png" alt="image-20250323131815258" />
      
    </figure>
</p>
<p>这是一个有序的消息链表，每个消息都有一个唯一的 ID 和对应的内容。ID 是一个时间戳和序列号的组合，用来保证消息的唯一性和递增性。内容是一个或多个键值对（类似 Hash 基本数据类型），用来存储消息的数据。</p>
<p>这里再对图中涉及到的一些概念，进行简单解释：</p>
<ul>
<li><code>Consumer Group</code>：消费者组用于组织和管理多个消费者。消费者组本身不处理消息，而是再将消息分发给消费者，由消费者进行真正的消费</li>
<li><code>last_delivered_id</code>：标识消费者组当前消费位置的游标，消费者组中任意一个消费者读取了消息都会使 last_delivered_id 往前移动。</li>
<li><code>pending_ids</code>：记录已经被客户端消费但没有 ack 的消息的 ID。</li>
</ul>
<p>下面是<code>Stream</code> 用作消息队列时常用的命令：</p>
<ul>
<li><code>XADD</code>：向流中添加新的消息。</li>
<li><code>XREAD</code>：从流中读取消息。</li>
<li><code>XREADGROUP</code>：从消费组中读取消息。</li>
<li><code>XRANGE</code>：根据消息 ID 范围读取流中的消息。</li>
<li><code>XREVRANGE</code>：与 <code>XRANGE</code> 类似，但以相反顺序返回结果。</li>
<li><code>XDEL</code>：从流中删除消息。</li>
<li><code>XTRIM</code>：修剪流的长度，可以指定修建策略（<code>MAXLEN</code>/<code>MINID</code>）。</li>
<li><code>XLEN</code>：获取流的长度。</li>
<li><code>XGROUP CREATE</code>：创建消费者组。</li>
<li><code>XGROUP DESTROY</code> ： 删除消费者组</li>
<li><code>XGROUP DELCONSUMER</code>：从消费者组中删除一个消费者。</li>
<li><code>XGROUP SETID</code>：为消费者组设置新的最后递送消息 ID</li>
<li><code>XACK</code>：确认消费组中的消息已被处理。</li>
<li><code>XPENDING</code>：查询消费组中挂起（未确认）的消息。</li>
<li><code>XCLAIM</code>：将挂起的消息从一个消费者转移到另一个消费者。</li>
<li><code>XINFO</code>：获取流(<code>XINFO STREAM</code>)、消费组(<code>XINFO GROUPS</code>)或消费者(<code>XINFO CONSUMERS</code>)的详细信息。</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。</p>
<p>总的来说，<code>Stream</code> 已经可以满足一个消息队列的基本要求了。不过，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。不过，如果你就是想要用 Redis 来做消息队列的话，那我建议你优先考虑 <code>Stream</code>，这是目前相对最优的 Redis 消息队列实现。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw" target="_blank">Redis 消息队列发展历程 - 阿里开发者 - 2022</a>。</p>


<h3 class="relative group">2.2.4 Redis可以做搜索引擎吗？ 
    <div id="224-redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%90%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#224-redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%90%97" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 是可以实现全文搜索引擎功能的，需要借助 <strong>RediSearch</strong> ，这是一个基于 Redis 的搜索引擎模块。</p>
<p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p>
<p>相比较于 Elasticsearch 来说，RediSearch 主要在下面两点上表现更优异一些：</p>
<ol>
<li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。</li>
<li>较低内存占用实现快速索引：RediSearch 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li>
</ol>
<p>对于小型项目的简单搜索场景来说，使用 RediSearch 来作为搜索引擎还是没有问题的（搭配 RedisJSON 使用）。</p>
<p>对于比较复杂或者数据规模较大的搜索场景还是不太建议使用 RediSearch 来作为搜索引擎，主要是因为下面这些限制和问题：</p>
<ol>
<li>数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。</li>
<li>分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。</li>
<li>聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。</li>
<li>生态较差：Elasticsearch 可以轻松和常见的一些系统/软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势。</li>
</ol>
<p>Elasticsearch 适用于全文搜索、复杂查询、实时数据分析和聚合的场景，而 RediSearch 适用于快速数据存储、缓存和简单查询的场景。</p>


<h3 class="relative group">2.2.5 如何基于Redis实现延时任务？ 
    <div id="225-%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#225-%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<blockquote>
<p>类似的问题：</p>
<ul>
<li>订单在 10 分钟后未支付就失效，如何用 Redis 实现？</li>
<li>红包 24 小时未被查收自动退还，如何用 Redis 实现？</li>
</ul></blockquote>
<p>基于 Redis 实现延时任务的功能无非就下面两种方案：</p>
<ol>
<li>Redis 过期事件监听</li>
<li>Redisson 内置的延时队列</li>
</ol>
<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。</p>
<p>Redisson 内置的延时队列具备下面这些优势：</p>
<ol>
<li><strong>减少了丢消息的可能</strong>：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</li>
<li><strong>消息不存在重复消费问题</strong>：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ol>


<h2 class="relative group">2.3 Redis数据类型 
    <div id="23-redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#23-redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看Reids重要知识点以及 <a href="https://redis.io/docs/data-types/" target="_blank">Redis 官方文档</a> 。</p>


<h3 class="relative group">2.3.1 Redis常用的数据类型 
    <div id="231-redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#231-redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 中比较常见的数据类型有下面这些：</p>
<ul>
<li><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。</li>
</ul>
<p>除了上面提到的之外，还有一些其他的比如 Bloom filter（布隆过滤器）、Bitfield（位域）。</p>


<h3 class="relative group">2.3.2 String的应用场景 
    <div id="232-string%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#232-string%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>……</li>
</ul>


<h3 class="relative group">2.3.3 String还是Hash存储对象数据更好 
    <div id="233-string%E8%BF%98%E6%98%AFhash%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#233-string%E8%BF%98%E6%98%AFhash%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>简单对比一下二者：</p>
<ul>
<li><strong>对象存储方式</strong>：String 存储的是序列化后的对象数据，存放的是整个对象，操作简单直接。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li><strong>内存消耗</strong>：Hash 通常比 String 更节省内存，特别是在字段较多且字段长度较短时。Redis 对小型 Hash 进行优化（如使用 ziplist 存储），进一步降低内存占用。</li>
<li><strong>复杂对象存储</strong>：String 在处理多层嵌套或复杂结构的对象时更方便，因为无需处理每个字段的独立存储和操作。</li>
<li><strong>性能</strong>：String 的操作通常具有 O(1) 的时间复杂度，因为它存储的是整个对象，操作简单直接，整体读写的性能较好。Hash 由于需要处理多个字段的增删改查操作，在字段较多且经常变动的情况下，可能会带来额外的性能开销。</li>
</ul>
<p>总结：</p>
<ul>
<li>在绝大多数情况下，<strong>String</strong> 更适合存储对象数据，尤其是当对象结构简单且整体读写是主要操作时。</li>
<li>如果你需要频繁操作对象的部分字段或节省内存，<strong>Hash</strong> 可能是更好的选择。</li>
</ul>


<h3 class="relative group">2.3.4 String的底层实现 
    <div id="234-string%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#234-string%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds" target="_blank">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）:</p>
<pre tabindex="0"><code>/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
</code></pre><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>字节</th>
          <th>位</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>sdshdr5</td>
          <td>&lt; 1</td>
          <td>&lt;8</td>
      </tr>
      <tr>
          <td>sdshdr8</td>
          <td>1</td>
          <td>8</td>
      </tr>
      <tr>
          <td>sdshdr16</td>
          <td>2</td>
          <td>16</td>
      </tr>
      <tr>
          <td>sdshdr32</td>
          <td>4</td>
          <td>32</td>
      </tr>
      <tr>
          <td>sdshdr64</td>
          <td>8</td>
          <td>64</td>
      </tr>
  </tbody>
</table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code>：实际存储字符串的数组</li>
<li><code>flags</code>：低三位保存类型标志</li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<pre tabindex="0"><code>struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};
</code></pre><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>


<h3 class="relative group">2.3.6 购物车信息用String还是Hash存储更好 
    <div id="236-%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8string%E8%BF%98%E6%98%AFhash%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#236-%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8string%E8%BF%98%E6%98%AFhash%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131842804.png" alt="image-20250323131842804" />
      
    </figure>
</p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>


<h3 class="relative group">2.3.7 使用Redis实现一个排行榜 
    <div id="237-%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#237-%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 中有一个叫做 <code>Sorted Set</code> （有序集合）的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131856464.png" alt="image-20250323131856464" />
      
    </figure>
</p>


<h3 class="relative group">2.3.8 Redis的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者B+树？ 
    <div id="238-redis%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85b%E6%A0%91" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#238-redis%E7%9A%84%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85b%E6%A0%91" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>这道面试题很多大厂比较喜欢问，难度还是有点大的。</p>
<ul>
<li>平衡树 vs 跳表：平衡树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong>。对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但是它的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表诞生的初衷就是为了克服平衡树的一些缺点。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</li>
<li>红黑树 vs 跳表：相比较于红黑树来说，跳表的实现也更简单一些，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
<li>B+树 vs 跳表：B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</li>
</ul>
<p>另外，我还单独写了一篇文章从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握 ：<a href="https://javaguide.cn/database/redis/redis-skiplist.html" target="_blank">Redis 为什么用跳表实现有序集合</a>。</p>


<h3 class="relative group">2.3.9 Set的应用场景 
    <div id="239-set%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#239-set%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p><code>Set</code> 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>


<h3 class="relative group">2.3.10 使用Set实现抽奖系统 
    <div id="2310-%E4%BD%BF%E7%94%A8set%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2310-%E4%BD%BF%E7%94%A8set%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>


<h3 class="relative group">2.3.11 使用Bitmap统计活跃用户 
    <div id="2311-%E4%BD%BF%E7%94%A8bitmap%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2311-%E4%BD%BF%E7%94%A8bitmap%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131913277.png" alt="image-20250323131913277" />
      
    </figure>
</p>
<p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<pre tabindex="0"><code>&gt; SETBIT 20210308 1 1
(integer) 0
&gt; SETBIT 20210308 2 1
(integer) 0
&gt; SETBIT 20210309 1 1
(integer) 0
</code></pre><p>统计 20210308~20210309 总活跃用户数:</p>
<pre tabindex="0"><code>&gt; BITOP and desk1 20210308 20210309
(integer) 1
&gt; BITCOUNT desk1
(integer) 1
</code></pre><p>统计 20210308~20210309 在线活跃用户数:</p>
<pre tabindex="0"><code>&gt; BITOP or desk2 20210308 20210309
(integer) 1
&gt; BITCOUNT desk2
(integer) 2
</code></pre>

<h3 class="relative group">2.3.12 使用HyperLogLog统计页面UV怎么做？ 
    <div id="2312-%E4%BD%BF%E7%94%A8hyperloglog%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2uv%E6%80%8E%E4%B9%88%E5%81%9A" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2312-%E4%BD%BF%E7%94%A8hyperloglog%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2uv%E6%80%8E%E4%B9%88%E5%81%9A" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>
<ul>
<li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li>
<li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li>
</ul>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<pre tabindex="0"><code>PFADD PAGE_1:UV USER1 USER2 ...... USERn
</code></pre><p>2、统计指定页面的 UV。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">PFCOUNT PAGE_1:UV
</span></span></code></pre></div>

<h2 class="relative group">2.5 Redis线程模型 
    <div id="25-redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#25-redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>


<h3 class="relative group">2.5.1 Redis单线程模型 
    <div id="251-redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#251-redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显：<strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131926940.png" alt="image-20250323131926940" />
      
    </figure>
</p>
<p>理器（file event handler)</p>
<p>相关阅读：<a href="http://remcarpediem.net/article/1aa2da89/" target="_blank">Redis 事件机制详解</a> 。</p>


<h3 class="relative group">2.5.2 Redis6.0 之前为什么不使用多线程 
    <div id="252-redis60-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#252-redis60-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>虽然说 Redis 是单线程模型，但实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p>
<p>为此，Redis 4.0 之后新增了几个异步命令：</p>
<ul>
<li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li>
<li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li>
<li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li>
</ul>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131939617.png" alt="image-20250323131939617" />
      
    </figure>
</p>
<p>redis4.0 more thread</p>
<p>总的来说，直到 Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<p>相关阅读：<a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank">为什么 Redis 选择单线程模型？</a> 。</p>


<h3 class="relative group">2.5.3 Redis6.0 之后为何引入了多线程 
    <div id="253-redis60-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#253-redis60-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p>
<pre tabindex="0"><code>io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程
</code></pre><p>另外：</p>
<ul>
<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>
<li>当设置 ssl 后，io-threads 将不工作。</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<pre tabindex="0"><code>io-threads-do-reads yes
</code></pre><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" target="_blank">Redis 6.0 新特性-多线程连环 13 问！</a></li>
<li><a href="https://segmentfault.com/a/1190000039223696" target="_blank">Redis 多线程网络模型全面揭秘</a>（推荐）</li>
</ul>


<h3 class="relative group">2.5.4 Redis后台线程 
    <div id="254-redis%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#254-redis%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li>
</ul>
<p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="err">#</span><span class="n">ifndef</span><span class="w"> </span><span class="n">__BIO_H</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">define</span><span class="w"> </span><span class="n">__BIO_H</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/* Exported API */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">void</span><span class="w"> </span><span class="nf">bioInit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">void</span><span class="w"> </span><span class="nf">bioCreateBackgroundJob</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">bioPendingJobsOfType</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">bioWaitStepOfType</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">time_t</span><span class="w"> </span><span class="nf">bioOlderJobOfType</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">void</span><span class="w"> </span><span class="nf">bioKillThreads</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/* Background job opcodes */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">define</span><span class="w"> </span><span class="n">BIO_CLOSE_FILE</span><span class="w">    </span><span class="n">0</span><span class="w"> </span><span class="cm">/* Deferred close(2) syscall. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">define</span><span class="w"> </span><span class="n">BIO_AOF_FSYNC</span><span class="w">     </span><span class="n">1</span><span class="w"> </span><span class="cm">/* Deferred AOF fsync. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">define</span><span class="w"> </span><span class="n">BIO_LAZY_FREE</span><span class="w">     </span><span class="n">2</span><span class="w"> </span><span class="cm">/* Deferred objects freeing. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">define</span><span class="w"> </span><span class="n">BIO_NUM_OPS</span><span class="w">       </span><span class="n">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">endif</span><span class="w">
</span></span></span></code></pre></div><p>关于 Redis 后台线程的详细介绍可以查看 <a href="https://juejin.cn/post/7102780434739626014" target="_blank">Redis 6.0 后台线程有哪些？</a> 这篇就文章。</p>


<h2 class="relative group">2.6 Redis内存管理 
    <div id="26-redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#26-redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.6.1 Redis 给缓存数据设置过期时间有什么用 
    <div id="261-redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#261-redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>内存是有限且珍贵的，如果不对缓存数据设置过期时间，那内存占用就会一直增长，最终可能会导致 OOM 问题。通过设置合理的过期时间，Redis 会自动删除暂时不需要的数据，为新的缓存数据腾出空间。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<pre tabindex="0"><code>127.0.0.1:6379&gt; expire key 60 # 数据在 60s 后过期
(integer) 1
127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)
OK
127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期
(integer) 56
</code></pre><p>注意 ⚠️：Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>


<h3 class="relative group">2.6.2 Redis是如何判断数据是否过期的 
    <div id="262-redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#262-redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323131956289.png" alt="image-20250323131956289" />
      
    </figure>
</p>
<p>Redis 过期字典</p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<pre tabindex="0"><code>typedef struct redisDb {
    ...

    dict *dict;     //数据库键空间,保存着数据库中所有键值对
    dict *expires   // 过期字典,保存着键的过期时间
    ...
} redisDb;
</code></pre><p>在查询一个 key 的时候，Redis 首先检查该 key 是否存在于过期字典中（时间复杂度为 O(1)），如果不在就直接返回，在的话需要判断一下这个 key 是否过期，过期直接删除 key 然后返回 null。</p>


<h3 class="relative group">2.6.3 Redis过期key删除策略 
    <div id="263-redis%E8%BF%87%E6%9C%9Fkey%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#263-redis%E8%BF%87%E6%9C%9Fkey%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>过期命令：</strong></p>
<p>Redis中通过<code>expire</code>命令可以给KEY设置<code>TTL</code>（过期时间），例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl"><span class="c1"># 写入一条数据</span>
</span></span><span class="line"><span class="cl"><span class="nb">set</span> num <span class="m">123</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 设置20秒过期时间</span>
</span></span><span class="line"><span class="cl">expire num <span class="m">20</span>
</span></span></code></pre></div><p>不过set命令本身也可以支持过期时间的设置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SHELL" data-lang="SHELL"><span class="line"><span class="cl"><span class="c1"># 写入一条数据并设置20s过期时间</span>
</span></span><span class="line"><span class="cl"><span class="nb">set</span> num EX <span class="m">20</span>
</span></span></code></pre></div><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p><strong>常用的过期数据的删除策略就下面这几种：</strong></p>
<ol>
<li><strong>惰性删除</strong>：只会在取出/查询 key 的时候才对数据进行过期检查。这种方式对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>
<li><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>
<li><strong>定时删除</strong>：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个定时器。</li>
</ol>
<p><strong>Redis 采用的那种删除策略呢？</strong></p>
<p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。</p>
<p>下面是我们详细介绍一下 Redis 中的定期删除具体是如何做的。</p>
<p>Redis 的定期删除过程是随机的（周期性地随机从设置了过期时间的 key 中抽查一批），所以并不保证所有过期键都会被立即删除。这也就解释了为什么有的 key 过期了，并没有被删除。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p>
<p>另外，定期删除还会受到执行时间和过期 key 的比例的影响：</p>
<ul>
<li>执行时间已经超过了阈值，那么就中断这一次定期删除循环，以避免使用过多的 CPU 时间。</li>
<li>如果这一批过期的 key 比例超过一个比例，就会重复执行此删除流程，以更积极地清理过期 key。相应地，如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li>
</ul>
<p>Redis 7.2 版本的执行时间阈值是 <strong>25ms</strong>，过期 key 比例设定值是 <strong>10%</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl"><span class="c1">#define ACTIVE_EXPIRE_CYCLE_FAST_DURATION 1000 /* Microseconds. */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 /* Max % of CPU to use. */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#define ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE 10 /* % of stale keys after which</span>
</span></span><span class="line"><span class="cl">                                                   we <span class="k">do</span> extra efforts. */
</span></span></code></pre></div><p><strong>每次随机抽查数量是多少？</strong></p>
<p><code>expire.c</code>中定义了每次随机抽查的数量，Redis 7.2 版本为 20 ，也就是说每次会随机选择 20 个设置了过期时间的 key 判断是否过期。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl"><span class="c1">#define ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP 20 /* Keys for each DB loop. */</span>
</span></span></code></pre></div><p><strong>如何控制定期删除的执行频率？</strong></p>
<p>在 Redis 中，定期删除的频率是由 <strong>hz</strong> 参数控制的。hz 默认为 10，代表每秒执行 10 次，也就是每秒钟进行 10 次尝试来查找并删除过期的 key。</p>
<p>hz 的取值范围为 1~500。增大 hz 参数的值会提升定期删除的频率。如果你想要更频繁地执行定期删除任务，可以适当增加 hz 的值，但这会加 CPU 的使用率。根据 Redis 官方建议，hz 的值不建议超过 100，对于大部分用户使用默认的 10 就足够了。</p>
<p>下面是 hz 参数的官方注释，我翻译了其中的重要信息（Redis 7.2 版本）。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132011750.png" alt="image-20250323132011750" />
      
    </figure>
</p>
<p>redis.conf 对于 hz 的注释</p>
<p>类似的参数还有一个 <strong>dynamic-hz</strong>，这个参数开启之后 Redis 就会在 hz 的基础上动态计算一个值。Redis 提供并默认启用了使用自适应 hz 值的能力，</p>
<p>这两个参数都在 Redis 配置文件 <code>redis.conf</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl"><span class="c1"># 默认为 10</span>
</span></span><span class="line"><span class="cl">hz <span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 默认开启</span>
</span></span><span class="line"><span class="cl">dynamic-hz yes
</span></span></code></pre></div><p>多提一嘴，除了定期删除过期 key 这个定期任务之外，还有一些其他定期任务例如关闭超时的客户端连接、更新统计信息，这些定期任务的执行频率也是通过 hz 参数决定。</p>
<p><strong>为什么定期删除不是把所有过期 key 都删除呢？</strong></p>
<p>这样会对性能造成太大的影响。如果我们 key 数量非常庞大的话，挨个遍历检查是非常耗时的，会严重影响性能。Redis 设计这种策略的目的是为了平衡内存和性能。</p>
<p><strong>为什么 key 过期之后不立马把它删掉呢？这样不是会浪费很多内存空间吗？</strong></p>
<p>因为不太好办到，或者说这种删除方式的成本太高了。假如我们使用延迟队列作为删除策略，这样存在下面这些问题：</p>
<ol>
<li>队列本身的开销可能很大：key 多的情况下，一个延迟队列可能无法容纳。</li>
<li>维护延迟队列太麻烦：修改 key 的过期时间就需要调整期在延迟队列中的位置，并且，还需要引入并发控制。</li>
</ol>


<h3 class="relative group">2.6.4 大量key集中过期怎么办 
    <div id="264-%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E6%80%8E%E4%B9%88%E5%8A%9E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#264-%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E6%80%8E%E4%B9%88%E5%8A%9E" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>当 Redis 中存在大量 key 在同一时间点集中过期时，可能会导致以下问题：</p>
<ul>
<li><strong>请求延迟增加：</strong> Redis 在处理过期 key 时需要消耗 CPU 资源，如果过期 key 数量庞大，会导致 Redis 实例的 CPU 占用率升高，进而影响其他请求的处理速度，造成延迟增加。</li>
<li><strong>内存占用过高：</strong> 过期的 key 虽然已经失效，但在 Redis 真正删除它们之前，仍然会占用内存空间。如果过期 key 没有及时清理，可能会导致内存占用过高，甚至引发内存溢出。</li>
</ul>
<p>为了避免这些问题，可以采取以下方案：</p>
<ol>
<li><strong>尽量避免 key 集中过期</strong>: 在设置键的过期时间时尽量随机一点。</li>
<li><strong>开启 lazy free 机制</strong>: 修改 <code>redis.conf</code> 配置文件，将 <code>lazyfree-lazy-expire</code> 参数设置为 <code>yes</code>，即可开启 lazy free 机制。开启 lazy free 机制后，Redis 会在后台异步删除过期的 key，不会阻塞主线程的运行，从而降低对 Redis 性能的影响。</li>
</ol>


<h3 class="relative group">2.6.5 Redis内存淘汰策略 
    <div id="265-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#265-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote>
<p>Redis 的内存淘汰策略只有在运行内存达到了配置的最大内存阈值时才会触发，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64 位操作系统下，<code>maxmemory</code> 默认为 0 ，表示不限制内存大小。32 位操作系统下，默认的最大内存值是 3GB。</p>
<p>你可以使用命令 <code>config get maxmemory</code> 来查看 <code>maxmemory</code>的值。</p>
<pre tabindex="0"><code>&gt; config get maxmemory
maxmemory
0
</code></pre><p>Redis 提供了 6 种内存淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。</li>
</ol>
<p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p>
<p><code>config.c</code>中定义了内存淘汰策略的枚举数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl">configEnum maxmemory_policy_enum<span class="o">[]</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;volatile-lru&#34;</span>, MAXMEMORY_VOLATILE_LRU<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;volatile-lfu&#34;</span>, MAXMEMORY_VOLATILE_LFU<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;volatile-random&#34;</span>,MAXMEMORY_VOLATILE_RANDOM<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;volatile-ttl&#34;</span>,MAXMEMORY_VOLATILE_TTL<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;allkeys-lru&#34;</span>,MAXMEMORY_ALLKEYS_LRU<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;allkeys-lfu&#34;</span>,MAXMEMORY_ALLKEYS_LFU<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;allkeys-random&#34;</span>,MAXMEMORY_ALLKEYS_RANDOM<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span><span class="s2">&#34;noeviction&#34;</span>,MAXMEMORY_NO_EVICTION<span class="o">}</span>,
</span></span><span class="line"><span class="cl">    <span class="o">{</span>NULL, 0<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span><span class="p">;</span>
</span></span></code></pre></div><p>你可以使用 <code>config get maxmemory-policy</code> 命令来查看当前 Redis 的内存淘汰策略。</p>
<pre tabindex="0"><code>&gt; config get maxmemory-policy
maxmemory-policy
noeviction
</code></pre><p>可以通过<code>config set maxmemory-policy 内存淘汰策略</code> 命令修改内存淘汰策略，立即生效，但这种方式重启 Redis 之后就失效了。修改 <code>redis.conf</code> 中的 <code>maxmemory-policy</code> 参数不会因为重启而失效，不过，需要重启之后修改才能生效。</p>
<pre tabindex="0"><code>maxmemory-policy noeviction
</code></pre><p>关于淘汰策略的详细说明可以参考 Redis 官方文档：https://redis.io/docs/reference/eviction/。</p>


<h2 class="relative group">2.7 Redis事务 
    <div id="27-redis%E4%BA%8B%E5%8A%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#27-redis%E4%BA%8B%E5%8A%A1" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.7.1 什么是Redis事务？ 
    <div id="271-%E4%BB%80%E4%B9%88%E6%98%AFredis%E4%BA%8B%E5%8A%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#271-%E4%BB%80%E4%B9%88%E6%98%AFredis%E4%BA%8B%E5%8A%A1" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系*/<em>ˈdræɡənflaɪ</em>/*型数据库的事务混淆了。</p>
<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>
<p>因此，Redis 事务是不建议在日常开发中使用的。</p>


<h3 class="relative group">2.7.2 如何使用Redis事务？ 
    <div id="272-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8redis%E4%BA%8B%E5%8A%A1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#272-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8redis%E4%BA%8B%E5%8A%A1" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl">&gt; MULTI
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; GET PROJECT
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; EXEC
</span></span><span class="line"><span class="cl">1<span class="o">)</span> OK
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">&#34;JavaGuide&#34;</span>
</span></span></code></pre></div><p><a href="https://redis.io/commands/multi" target="_blank"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec" target="_blank"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard" target="_blank"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl">&gt; MULTI
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; GET PROJECT
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; DISCARD
</span></span><span class="line"><span class="cl">OK
</span></span></code></pre></div><p>你可以通过<a href="https://redis.io/commands/watch" target="_blank"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl"><span class="c1"># 客户端 1</span>
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;RustGuide&#34;</span>
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; WATCH PROJECT
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; MULTI
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 客户端 2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span>
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;GoGuide&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 客户端 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 修改失败，因为 PROJECT 的值被客户端2修改了</span>
</span></span><span class="line"><span class="cl">&gt; EXEC
</span></span><span class="line"><span class="cl"><span class="o">(</span>nil<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; GET PROJECT
</span></span><span class="line"><span class="cl"><span class="s2">&#34;GoGuide&#34;</span>
</span></span></code></pre></div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714" target="_blank">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>
<p>事务内部修改 WATCH 监视的 Key：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-BASH" data-lang="BASH"><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide&#34;</span>
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; WATCH PROJECT
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; MULTI
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide1&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide2&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide3&#34;</span>
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; EXEC
</span></span><span class="line"><span class="cl">1<span class="o">)</span> OK
</span></span><span class="line"><span class="cl">2<span class="o">)</span> OK
</span></span><span class="line"><span class="cl">3<span class="o">)</span> OK
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; GET PROJECT
</span></span><span class="line"><span class="cl"><span class="s2">&#34;JavaGuide3&#34;</span>
</span></span></code></pre></div><p>事务外部修改 WATCH 监视的 Key：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide&#34;</span>
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; WATCH PROJECT
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; SET PROJECT <span class="s2">&#34;JavaGuide2&#34;</span>
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; MULTI
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">&gt; GET USER
</span></span><span class="line"><span class="cl">QUEUED
</span></span><span class="line"><span class="cl">&gt; EXEC
</span></span><span class="line"><span class="cl"><span class="o">(</span>nil<span class="o">)</span>
</span></span></code></pre></div><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank">https://redis.io/topics/transactions</a> 如下：</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132032902.png" alt="image-20250323132032902" />
      
    </figure>
</p>


<h3 class="relative group">2.7.3 Redis事务支持原子性吗？ 
    <div id="273-redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#273-redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132045397.png" alt="image-20250323132045397" />
      
    </figure>
</p>
<p>Redis 为什么不支持回滚</p>
<p><strong>相关 issue</strong> :</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank">issue#452: 关于 Redis 事务不满足原子性的问题</a> 。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/491" target="_blank">Issue#491:关于 Redis 没有事务回滚？</a></li>
</ul>


<h3 class="relative group">2.7.4 Redis事务支持持久性吗？ 
    <div id="274-redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#274-redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<pre tabindex="0"><code>appendfsync always    #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟调用fsync函数同步一次AOF文件
appendfsync no        #让操作系统决定何时进行同步，一般为30秒一次
</code></pre><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>
<p>因此，Redis 事务的持久性也是没办法保证的。</p>


<h3 class="relative group">2.7.5 如何解决Redis事务的缺陷 
    <div id="275-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#275-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>
<p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/" target="_blank">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>


<h2 class="relative group">2.8 Redis性能优化 
    <div id="28-redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#28-redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ" target="_blank">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html" target="_blank">Redis 常见阻塞原因总结 - JavaGuide</a></li>
</ul>


<h3 class="relative group">2.8.1 使用批量操作减少网络传输 
    <div id="281-%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#281-%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>
<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>
<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。</p>


<h4 class="relative group">2.8.1.1 原生批量操作命令 
    <div id="2811-%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2811-%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Redis 中有一些原生支持批量操作的命令，比如：</p>
<ul>
<li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li>
<li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>
<li><code>SADD</code>（向指定集合添加一个或多个元素）</li>
<li>……</li>
</ul>
<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>
<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>
<ol>
<li>找到 key 对应的所有 hash slot；</li>
<li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li>
<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>
</ol>
<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>
<blockquote>
<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>
<p>我在 <a href="https://javaguide.cn/database/redis/redis-cluster.html" target="_blank">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p></blockquote>


<h4 class="relative group">2.8.1.2 pipline 
    <div id="2812-pipline" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2812-pipline" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>
<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>
<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>
<ul>
<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>
<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>
<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>
</ul>
<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>
<ul>
<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>
<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li>
</ul>
<blockquote>
<p>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p></blockquote>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132119518.png" alt="image-20250323132119518" />
      
    </figure>
</p>
<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>


<h4 class="relative group">2.8.1.3 lua脚本 
    <div id="2813-lua%E8%84%9A%E6%9C%AC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2813-lua%E8%84%9A%E6%9C%AC" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>
<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>
<p>不过， Lua 脚本依然存在下面这些缺陷：</p>
<ul>
<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>
<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>
</ul>


<h3 class="relative group">2.8.2 大量key集中过期问题 
    <div id="282-%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#282-%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>


<h3 class="relative group">2.8.3 Redis bigkey（大 Key） 
    <div id="283-redis-bigkey%E5%A4%A7-key" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#283-redis-bigkey%E5%A4%A7-key" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.8.3.1 什么是bigkey？ 
    <div id="2831-%E4%BB%80%E4%B9%88%E6%98%AFbigkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2831-%E4%BB%80%E4%B9%88%E6%98%AFbigkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：</p>
<ul>
<li>String 类型的 value 超过 1MB</li>
<li>复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个（不过，对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</li>
</ul>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132140815.png" alt="image-20250323132140815" />
      
    </figure>
</p>


<h4 class="relative group">2.8.3.2 bigkey是怎么产生的？有什么危害？ 
    <div id="2832-bigkey%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2832-bigkey%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>bigkey 通常是由于下面这些原因产生的：</p>
<ul>
<li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li>
<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>
<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>
</ul>
<p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。</p>
<p>在 <a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html" target="_blank">Redis 常见阻塞原因总结</a>这篇文章中我们提到：大 key 还会造成阻塞问题。具体来说，主要体现在下面三个方面：</p>
<ol>
<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>工作线程阻塞：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
</ol>
<p>大 key 造成的阻塞问题还会进一步影响到主从同步和集群扩容。</p>
<p>综上，大 key 带来的潜在问题是非常多的，我们应该尽量避免 Redis 中存在 bigkey。</p>


<h4 class="relative group">2.8.3.3 如何发现bugkey? 
    <div id="2833-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0bugkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2833-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0bugkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># redis-cli -p 6379 --bigkeys</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Scanning the entire keyspace to find biggest keys as well as</span>
</span></span><span class="line"><span class="cl"><span class="c1"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span>
</span></span><span class="line"><span class="cl"><span class="c1"># per 100 SCAN commands (not usually needed).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>00.00%<span class="o">]</span> Biggest string found so far <span class="s1">&#39;&#34;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&#34;&#39;</span> with <span class="m">4437</span> bytes
</span></span><span class="line"><span class="cl"><span class="o">[</span>00.00%<span class="o">]</span> Biggest list   found so far <span class="s1">&#39;&#34;my-list&#34;&#39;</span> with <span class="m">17</span> items
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------- summary -------
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sampled <span class="m">5</span> keys in the keyspace!
</span></span><span class="line"><span class="cl">Total key length in bytes is <span class="m">264</span> <span class="o">(</span>avg len 52.80<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Biggest   list found <span class="s1">&#39;&#34;my-list&#34;&#39;</span> has <span class="m">17</span> items
</span></span><span class="line"><span class="cl">Biggest string found <span class="s1">&#39;&#34;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&#34;&#39;</span> has <span class="m">4437</span> bytes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">1</span> lists with <span class="m">17</span> items <span class="o">(</span>20.00% of keys, avg size 17.00<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">0</span> hashs with <span class="m">0</span> fields <span class="o">(</span>00.00% of keys, avg size 0.00<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">4</span> strings with <span class="m">4831</span> bytes <span class="o">(</span>80.00% of keys, avg size 1207.75<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">0</span> streams with <span class="m">0</span> entries <span class="o">(</span>00.00% of keys, avg size 0.00<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">0</span> sets with <span class="m">0</span> members <span class="o">(</span>00.00% of keys, avg size 0.00<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">0</span> zsets with <span class="m">0</span> members <span class="o">(</span>00.00% of keys, avg size 0.00
</span></span></code></pre></div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 String 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p>
<p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p>
<p><strong>2、使用 Redis 自带的 SCAN 命令</strong></p>
<p><code>SCAN</code> 命令可以按照一定的模式和数量返回匹配的 key。获取了 key 之后，可以利用 <code>STRLEN</code>、<code>HLEN</code>、<code>LLEN</code>等命令返回其长度或成员数量。</p>
<table>
  <thead>
      <tr>
          <th>数据结构</th>
          <th>命令</th>
          <th>复杂度</th>
          <th>结果（对应 key）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>String</td>
          <td>STRLEN</td>
          <td>O(1)</td>
          <td>字符串值的长度</td>
      </tr>
      <tr>
          <td>Hash</td>
          <td>HLEN</td>
          <td>O(1)</td>
          <td>哈希表中字段的数量</td>
      </tr>
      <tr>
          <td>List</td>
          <td>LLEN</td>
          <td>O(1)</td>
          <td>列表元素数量</td>
      </tr>
      <tr>
          <td>Set</td>
          <td>SCARD</td>
          <td>O(1)</td>
          <td>集合元素数量</td>
      </tr>
      <tr>
          <td>Sorted Set</td>
          <td>ZCARD</td>
          <td>O(1)</td>
          <td>有序集合的元素数量</td>
      </tr>
  </tbody>
</table>
<p>对于集合类型还可以使用 <code>MEMORY USAGE</code> 命令（Redis 4.0+），这个命令会返回键值对占用的内存空间。</p>
<p><strong>3、借助开源工具分析 RDB 文件。</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank">redis-rdb-tools</a>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys" target="_blank">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<p><strong>4、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132201240.png" alt="image-20250323132201240" />
      
    </figure>
</p>


<h4 class="relative group">2.8.3.4 如何处理bigkey？ 
    <div id="2834-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86bigkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2834-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86bigkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。</li>
<li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>
<li><strong>采用合适的数据结构</strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）。</li>
<li><strong>开启 lazy-free（惰性删除/延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ul>


<h3 class="relative group">2.8.4 Redis hotkey（热 Key） 
    <div id="284-redis-hotkey%E7%83%AD-key" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#284-redis-hotkey%E7%83%AD-key" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.8.4.1 什么是hotkey？ 
    <div id="2841-%E4%BB%80%E4%B9%88%E6%98%AFhotkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2841-%E4%BB%80%E4%B9%88%E6%98%AFhotkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 <strong>hotkey（热 Key）</strong>。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p>
<p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>


<h4 class="relative group">2.8.4.2 hotkey有什么危害 
    <div id="2842-hotkey%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2842-hotkey%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p>
<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>


<h4 class="relative group">2.8.4.3 如何发现hotkey？ 
    <div id="2843-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0hotkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2843-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0hotkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>1、使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p>
<p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p>
<p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p>
<pre tabindex="0"><code># redis-cli -p 6379 --hotkeys

# Scanning the entire keyspace to find hot keys as well as
# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec
# per 100 SCAN commands (not usually needed).

Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.
</code></pre><p>Redis 中有两种 LFU 算法：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<p>以下是配置文件 <code>redis.conf</code> 中的示例：</p>
<pre tabindex="0"><code># 使用 volatile-lfu 策略
maxmemory-policy volatile-lfu

# 或者使用 allkeys-lfu 策略
maxmemory-policy allkeys-lfu
</code></pre><p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>
<p><strong>2、使用<code>MONITOR</code> 命令。</strong></p>
<p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>
<p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>
<pre tabindex="0"><code># redis-cli
127.0.0.1:6379&gt; MONITOR
OK
1683638260.637378 [0 172.17.0.1:61516] &#34;ping&#34;
1683638267.144236 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
1683638268.941863 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
1683638269.551671 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
1683638270.646256 [0 172.17.0.1:61516] &#34;ping&#34;
1683638270.849551 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
1683638271.926945 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
1683638274.276599 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet2&#34;
1683638276.327234 [0 172.17.0.1:61518] &#34;smembers&#34; &#34;mySet&#34;
</code></pre><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p>
<p><strong>3、借助开源项目。</strong></p>
<p>京东零售的 <a href="https://gitee.com/jd-platform-opensource/hotkey" target="_blank">hotkey</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/jd-hotkey.png" alt="京东零售开源的 hotkey" />
      
    </figure>
</p>
<p>京东零售开源的 hotkey</p>
<p><strong>4、根据业务情况提前预估。</strong></p>
<p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p>
<p><strong>5、业务代码中记录分析。</strong></p>
<p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p>
<p><strong>6、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<p>这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132233055.png" alt="image-20250323132233055" />
      
    </figure>
</p>


<h4 class="relative group">2.8.4.4 如何解决hotkey？ 
    <div id="2844-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hotkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2844-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hotkey" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li>
<li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li>
<li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>
</ul>
<p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p>
<p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132251912.png" alt="image-20250323132251912" />
      
    </figure>
</p>


<h3 class="relative group">2.8.5 查询慢命令 
    <div id="285-%E6%9F%A5%E8%AF%A2%E6%85%A2%E5%91%BD%E4%BB%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#285-%E6%9F%A5%E8%AF%A2%E6%85%A2%E5%91%BD%E4%BB%A4" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.8.5.1 为什么会有查询慢命令 
    <div id="2851-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%9F%A5%E8%AF%A2%E6%85%A2%E5%91%BD%E4%BB%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2851-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%9F%A5%E8%AF%A2%E6%85%A2%E5%91%BD%E4%BB%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
<p>Redis 为什么会有慢查询命令呢？</p>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>
<li>……</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>……</li>
</ul>


<h4 class="relative group">2.8.5.2 如何找到慢查询命令 
    <div id="2852-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2852-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p>
<pre tabindex="0"><code># The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128
</code></pre><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>
<pre tabindex="0"><code># 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录
CONFIG SET slowlog-log-slower-than 10000
# 只保留最近 128 条耗时命令
CONFIG SET slowlog-max-len 128
</code></pre><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>
<pre tabindex="0"><code>127.0.0.1:6379&gt; SLOWLOG GET #慢日志查询
 1) 1) (integer) 5
   2) (integer) 1684326682
   3) (integer) 12000
   4) 1) &#34;KEYS&#34;
      2) &#34;*&#34;
   5) &#34;172.17.0.1:61152&#34;
   6) &#34;&#34;
  // ...
</code></pre><p>慢查询日志中的每个条目都由以下六个值组成：</p>
<ol>
<li>唯一渐进的日志标识符。</li>
<li>处理记录命令的 Unix 时间戳。</li>
<li>执行所需的时间量，以微秒为单位。</li>
<li>组成命令参数的数组。</li>
<li>客户端 IP 地址和端口。</li>
<li>客户端名称。</li>
</ol>
<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p>下面是其他比较常用的慢查询相关的命令：</p>
<pre tabindex="0"><code># 返回慢查询命令的数量
127.0.0.1:6379&gt; SLOWLOG LEN
(integer) 128
# 清空慢查询命令
127.0.0.1:6379&gt; SLOWLOG RESET
OK
</code></pre>

<h3 class="relative group">2.8.6 Redis 内存碎片 
    <div id="286-redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#286-redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p><strong>相关问题</strong>：</p>
<ol>
<li>什么是内存碎片?为什么会有 Redis 内存碎片?</li>
<li>如何清理 Redis 内存碎片？</li>
</ol>
<p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-memory-fragmentation.html" target="_blank">Redis 内存碎片详解</a>。</p>


<h2 class="relative group">2.9 Redis生产问题 
    <div id="29-redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#29-redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98" aria-label="Anchor">#</a>
    </span>        
    
</h2>


<h3 class="relative group">2.9.1 缓存穿透 
    <div id="291-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#291-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.9.1.1 什么是缓存穿透？ 
    <div id="2911-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2911-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132318982.png" alt="image-20250323132318982" />
      
    </figure>
</p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>


<h4 class="relative group">2.9.1.2 有哪些解决方法？ 
    <div id="2912-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2912-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">getObjectInclNullById</span><span class="p">(</span><span class="n">Integer</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 从缓存中获取数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">cacheValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 缓存为空</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cacheValue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 从数据库中获取</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">storageValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">storage</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 缓存空对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cache</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">storageValue</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 如果存储数据为空，需要设置一个过期时间(300秒)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">storageValue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 必须设置过期时间，否则有被攻击的风险</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cache</span><span class="p">.</span><span class="na">expire</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">storageValue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cacheValue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132337168.png" alt="image-20250323132337168" />
      
    </figure>
</p>
<p>Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。这样来算的话，申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 KB ≈ 122KB 的空间。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132347145.png" alt="image-20250323132347145" />
      
    </figure>
</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132402408.png" alt="image-20250323132402408" />
      
    </figure>
</p>
<p>更多关于布隆过滤器的详细介绍可以看看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html" target="_blank">不了解布隆过滤器？一文给你整的明明白白！</a> ，强烈推荐。</p>
<p><strong>3）接口限流</strong></p>
<p>根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p>
<p>后面提到的缓存击穿和雪崩都可以配合接口限流来解决，毕竟这些问题的关键都是有很多请求落到了数据库上造成数据库压力过大。</p>
<p>限流的具体方案可以参考这篇文章：<a href="https://javaguide.cn/high-availability/limit-request.html" target="_blank">服务限流详解</a>。</p>


<h3 class="relative group">2.9.2 缓存击穿 
    <div id="292-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#292-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.9.2.1 什么是缓存击穿？ 
    <div id="2921-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2921-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132428554.png" alt="image-20250323132428554" />
      
    </figure>
</p>
<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>


<h4 class="relative group">2.9.2.2 有哪些解决办法？ 
    <div id="2922-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2922-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<ol>
<li>
<p><strong>永不过期</strong>（不推荐）：设置热点数据永不过期或者过期时间比较长。</p>
</li>
<li>
<p><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</p>
</li>
<li>
<p><strong>加锁</strong>（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。</p>
<p>关于加锁的机制：</p>
<ol>
<li>使用互斥锁：当缓存失效时，不立即去 load db，先使用如Redis的 SETNX 去设置一个互斥锁。当操作成功返回时，再进行load db 的操作并回设缓存，否则重试get缓存的方法。</li>
<li>设置当前key逻辑过期，大概思路如下：1) 在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间；2) 当查询的时候，从redis取出数据后判断时间是否过期；3) 如果过期，则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据可能不是最新的。</li>
</ol>
</li>
</ol>


<h4 class="relative group">2.9.2.3 缓存穿透和缓存击穿有什么区别 
    <div id="2923-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2923-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>


<h3 class="relative group">2.9.3 缓存雪崩 
    <div id="293-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#293-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" aria-label="Anchor">#</a>
    </span>        
    
</h3>


<h4 class="relative group">2.9.3.1 什么是缓存雪崩 
    <div id="2931-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2931-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p>
    <figure>
      <img class="my-0 rounded-md" loading="lazy" src="./assets/image-20250323132442859.png" alt="image-20250323132442859" />
      
    </figure>
</p>
<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>


<h4 class="relative group">2.9.3.2 有哪些解决办法 
    <div id="2932-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2932-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案，详细介绍可以参考：<a href="https://javaguide.cn/database/redis/redis-cluster.html" target="_blank">Redis 集群详解(付费)</a>。</li>
<li><strong>多级缓存</strong>：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>
</ol>
<p><strong>针对大量缓存同时失效的情况：</strong></p>
<ol>
<li><strong>设置随机失效时间</strong>（可选）：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li>
<li><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li><strong>持久缓存策略</strong>（看情况）：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li>
</ol>


<h4 class="relative group">2.9.3.3 缓存预热如何实现 
    <div id="2933-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2933-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>常见的缓存预热方式有两种：</p>
<ol>
<li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>
<li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>
</ol>


<h4 class="relative group">2.9.3.4 缓存雪崩和缓存击穿有什么区别 
    <div id="2934-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#2934-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>


<h3 class="relative group">2.9.4 如何保证缓存和数据库数据的一致性 
    <div id="294-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#294-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新数据库，然后直接删除缓存 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说有两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加缓存更新重试机制（常用）</strong>：如果缓存服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。不过，这里更适合引入消息队列实现异步重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。虽然说多引入了一个消息队列，但其整体带来的收益还是要更高一些。</li>
</ol>
<p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd" target="_blank">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a>。</p>


<h3 class="relative group">2.9.5 哪些情况可能会导致Redis阻塞 
    <div id="295-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4redis%E9%98%BB%E5%A1%9E" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#295-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4redis%E9%98%BB%E5%A1%9E" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>单独抽了一篇文章来总结可能会导致 Redis 阻塞的情况：<a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html" target="_blank">Redis 常见阻塞原因总结</a>。</p>


<h2 class="relative group">2.10 Redis集群 
    <div id="210-redis%E9%9B%86%E7%BE%A4" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#210-redis%E9%9B%86%E7%BE%A4" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><strong>Redis Sentinel</strong>：</p>
<ol>
<li>什么是 Sentinel？ 有什么用？</li>
<li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li>
<li>Sentinel 是如何实现故障转移的？</li>
<li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li>
<li>Sentinel 如何选择出新的 master（选举机制）?</li>
<li>如何从 Sentinel 集群中选择出 Leader ？</li>
<li>Sentinel 可以防止脑裂吗？</li>
</ol>
<p><strong>Redis Cluster</strong>：</p>
<ol>
<li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li>
<li>Redis Cluster 是如何分片的？</li>
<li>为什么 Redis Cluster 的哈希槽是 16384 个?</li>
<li>如何确定给定 key 的应该分布到哪个哈希槽中？</li>
<li>Redis Cluster 支持重新分配哈希槽吗？</li>
<li>Redis Cluster 扩容缩容期间可以提供服务吗？</li>
<li>Redis Cluster 中的节点是怎么进行通信的？</li>
</ol>
<p><strong>参考答案</strong>：<a href="https://javaguide.cn/database/redis/redis-cluster.html" target="_blank">Redis 集群详解（付费）</a>。</p>


<h2 class="relative group">2.11 Redis使用规范 
    <div id="211-redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#211-redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>
<ol>
<li>使用连接池：避免频繁创建关闭客户端连接。</li>
<li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li>
<li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li>
<li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>
<li>禁止长时间开启 monitor：对性能影响比较大。</li>
<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>
<li>……</li>
</ol>
<p>相关文章推荐：<a href="https://developer.aliyun.com/article/531067" target="_blank">阿里云 Redis 开发规范</a> 。</p>

          
          
          
        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_posts\/1742706434897-redis\/index.md"
        var oid_likes = "likes_posts\/1742706434897-redis\/index.md"
      </script>
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
      
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/posts/1742633078455-mysql%E5%9F%BA%E7%A1%80/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >MySQL基础</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2025-03-22T00:00:00&#43;00:00">22 March 2025</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/posts/1743605568426-restful-api/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  >Restful API</span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="2025-04-02T00:00:00&#43;00:00">2 April 2025</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top" title="Scroll to top">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
    <nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400">
      <ul class="flex flex-col list-none sm:flex-row">
        
        <li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0">
          <a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=""
            title="">
            
            
          </a>
        </li>
        
      </ul>
    </nav>
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2025
      山有木兮
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="https://shanymxc.github.io/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
