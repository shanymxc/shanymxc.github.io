
[{"content":"","date":"11 March 2025","externalUrl":null,"permalink":"/","section":"Blog homepage","summary":"","title":"Blog homepage","type":"page"},{"content":"","date":"11 March 2025","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":"","date":"11 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"11 March 2025","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":"","date":"11 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"an example to get you started\n常见API\u0026amp;对象克隆 # 1.1 Math类 # Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。Math类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。\n常见方法：\npublic static int abs(int a)\t// 返回参数的绝对值 public static double ceil(double a)\t// 返回大于或等于参数的最小整数 public static double floor(double a)\t// 返回小于或等于参数的最大整数 public static int round(float a)\t// 按照四舍五入返回最接近参数的int类型的值 public static int max(int a,int b)\t// 获取两个int值中的较大值 public static int min(int a,int b)\t// 获取两个int值中的较小值 public static double pow (double a,double b)\t// 计算a的b次幂的值 public static double random()\t// 返回一个[0.0,1.0)的随机值 13.2 System类 # System类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。System包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。我们不能直接通过new关键字去创建System类的对象。同时我们发现System类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用。\n常见方法：\npublic static long currentTimeMillis()\t// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置） public static void exit(int status)\t// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); // 进行数值元素copy arraycopy方法底层细节：\n1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n13.3 Runtime # Runtime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息。\n常见方法：\npublic static Runtime getRuntime()\t//当前系统的运行环境对象 public void exit(int status)\t//停止虚拟机 public int availableProcessors()\t//获得CPU的线程数 public long maxMemory()\t//JVM能从系统中获取总内存大小（单位byte） public long totalMemory()\t//JVM已经从系统中获取总内存大小（单位byte） public long freeMemory()\t//JVM剩余内存大小（单位byte） public Process exec(String command) //运行cmd命令 13.4 Object类\u0026amp;对象克隆 # Object类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。\n常见方法：\n/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */ public final native Class\u0026lt;?\u0026gt; getClass() /** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */ public native int hashCode() /** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */ public boolean equals(Object obj) /** * native 方法，用于创建并返回当前对象的一份拷贝。 */ protected native Object clone() throws CloneNotSupportedException /** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */ public String toString() /** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */ public final native void notify() /** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */ public final native void notifyAll() /** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */ public final native void wait(long timeout) throws InterruptedException /** * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 */ public final void wait(long timeout, int nanos) throws InterruptedException /** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */ public final void wait() throws InterruptedException /** * 实例被垃圾回收器回收的时候触发的操作 */ protected void finalize() throws Throwable { } 在通过输出语句输出一个对象时，默认调用的就是toString()方法 输出地址值一般没有意义，我们可以通过重写toString方法去输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -\u0026gt; Generate -\u0026gt; 选择toString） toString方法的作用：以良好的格式，更方便的展示对象中的属性值 一般情况下Jdk所提供的类都会重写Object类中的toString方法 13.4.1 ==和equals()的区别 # == 对于基本类型和引用类型的作用效果是不同的：\n对于基本数据类型来说，== 比较的是值。 对于引用数据类型来说，== 比较的是对象的内存地址。 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。\nequals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。\nObject 类 equals() 方法：\npublic boolean equals(Object obj) { return (this == obj); } equals() 方法存在两种使用情况：\n类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。 String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。\n当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。\n13.4.2 String#equals()和Object#equals()的区别 # String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。\n13.4.3 对象克隆 # 对象克隆的分类：\n深克隆和浅克隆，还有一个引用克隆，但不常见。\n浅克隆：\n​\t不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来\n​\t基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。也就是说，==浅拷贝（克隆）会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。==\n​\tObject类默认的是浅克隆，想要进行深克隆，就需要重写clone方法并修改里面的方法体。\n深克隆：\n​\t基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的。也就是说，==深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。==\n引用拷贝：\n简单来说，==引用拷贝就是两个不同的引用指向同一个对象。==\n13.4.4 hashCode() # hashCode()有什么用？\nhashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。\nhashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是：Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n该方法在 Oracle OpenJDK8 中默认是 \u0026ldquo;使用线程局部状态来实现 Marsaglia\u0026rsquo;s xor-shift 随机数生成\u0026rdquo;, 并不是 \u0026ldquo;地址\u0026rdquo; 或者 \u0026ldquo;地址转换而来\u0026rdquo;, 不同 JDK/VM 可能不同在 Oracle OpenJDK8 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n为什么要有hashCode?\n我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？\n下面这段内容摘自我的 Java 启蒙书《Head First Java》:\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n其实， hashCode() 和 equals()都是用于比较两个对象是否相等。\n为什么 JDK 还要同时提供这两个方法呢？\n因为在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）！\n我们在前面也提到了添加元素进HashSet的过程，如果 HashSet 在对比的时候，同样的 hashCode 有多个对象，它会继续使用 equals() 来判断是否真的相同。也就是说 hashCode 帮助我们大大缩小了查找成本。\n为什么不只提供 hashCode() 方法呢？\n这是因为两个对象的hashCode 值相等并不代表两个对象就相等。\n为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？\n因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。\n总结下来就是：\n如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。 为什么重写equals()时必须重写hashCode()方法？\n因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。\n如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。\n13.4.5 两个不相等的对象有可能具有相同的hashCode吗 # ==有可能== **两个不相等的对象有可能具有相同的哈希码。**哈希码是由对象的哈希函数生成的一个整数值，用于支持快速查找和比较对象。 然而，由于哈希码的范围通常比对象的数量小得多，因此不同的对象可能会产生相同的哈希码。这种情况被称为哈希冲突。 哈希算法设计的目标是将不同的输入均匀分布在哈希码空间中，但无法避免完全消除冲突。因此，当发生哈希冲突时，哈希算法会使用特定的策略（例如链表或树结构）来处理这些冲突，以确保不同的对象可以存储在同一个哈希桶中。 综上所述，虽然不同的对象可能具有相同的哈希码，但哈希码仅用于初步判断对象是否可能相等，最终的相等性检查还需要通过 equals() 方法进行。因此，在重写 equals() 方法时，也应该相应地重写 hashCode() 方法，以尽量减少哈希冲突的发生。\n13.4.6 值传递和引用传递 # 值传递和引用传递是程序中常用的参数传递方式。\n值传递是指在函数调用时，将实际参数的值复制一份传递给形式参数，在函数内对形式参数的修改不会影响到实际参数的值。这意味着函数内部对形参的改变不会影响到函数外部的变量。在值传递中，对形参的修改只作用于函数内部。 引用传递是指在函数调用时，将实际参数的引用或地址传递给形式参数，函数内部对形参的修改会影响到实际参数。这意味着函数内部对形参的改变会影响到函数外部的变量。在引用传递中，对形参的修改会直接作用于函数外部的变量。 需要注意的是，引用传递实际上传递的是对象的引用或地址，并不是对象本身。对于基本数据类型（如整数、浮点数等），虽然也可以通过指针进行引用传递，但由于基本数据类型的值通常较小，因此通常采用值传递的方式。\n13.5 Objects类 # Objects类所在包是在java.util包下，因此在使用的时候需要进行导包。并且Objects类是被final修饰的，因此该类不能被继承。**Objects类提供了一些对象常见操作的方法。比如判断对象是否相等，判断对象是否为null等等。**我们可以发现Objects类中无无参构造方法，因此我们不能使用new关键字去创建Objects的对象。同时我们可以发现Objects类中所提供的方法都是静态的。因此我们可以通过类名直接去调用这些方法。\n常见方法：\npublic static String toString(Object o) // 获取对象的字符串表现形式 public static boolean equals(Object a, Object b)\t// 比较两个对象是否相等 public static boolean isNull(Object obj)\t// 判断对象是否为null public static boolean nonNull(Object obj)\t// 判断对象是否不为null 了解的方法：\npublic static \u0026lt;T\u0026gt; T requireNonNull(T obj)\t// 检查对象是否不为null,如果为null直接抛出异常；如果不是null返回该对象； public static \u0026lt;T\u0026gt; T requireNonNullElse(T obj, T defaultObj) // 检查对象是否不为null，如果不为null，返回该对象；如果为null返回defaultObj值 public static \u0026lt;T\u0026gt; T requireNonNullElseGet(T obj, Supplier\u0026lt;? extends T\u0026gt; supplier)\t// 检查对象是否不为null，如果不为null，返回该对象；如果\t// 为null,返回由Supplier所提供的值 13.6 BigIntrger类 # 基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。\n在 Java 中，64 位 long 整型是最大的整数类型。\nBigInteger，可以理解为：大的整数。理论上最大到42亿的21亿次方，基本上在内存撑爆之前，都无法达到这个上限。但相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。\nBigInteger所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigInteger类进行大整数的计算。\n常见构造方法：\npublic BigInteger(int num, Random rnd) //获取随机大整数，范围：[0 ~ 2的num次方-1] public BigInteger(String val) //获取指定的大整数 public BigInteger(String val, int radix) //获取指定进制的大整数 下面这个不是构造，而是一个静态方法获取BigInteger对象 public static BigInteger valueOf(long val) //静态方法获取BigInteger的对象，内部有优化 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。 如果BigInteger表示的超出long的范围，可以用构造方法获取。 对象一旦创建，BigInteger内部记录的值不能发生改变。 只要进行计算都会产生一个新的BigInteger对象 常见成员方法：\nBigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\npublic BigInteger add(BigInteger val)\t//加法 public BigInteger subtract(BigInteger val)\t//减法 public BigInteger multiply(BigInteger val)\t//乘法 public BigInteger divide(BigInteger val)\t//除法 public BigInteger[] divideAndRemainder(BigInteger val)\t//除法，获取商和余数 public boolean equals(Object x) //比较是否相同 public BigInteger pow(int exponent) //次幂、次方 public BigInteger max/min(BigInteger val) //返回较大值/较小值 public int intValue(BigInteger val) //转为int类型整数，超出范围数据有误 底层存储方式：\n对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。\n数组中最多能存储元素个数：21亿多\n数组中每一位能表示的数字：42亿多\n理论上，BigInteger能表示的最大数字为：42亿的21亿次方。\n但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。\n存储方式如图所示：\n13.7 BigDecimal类 # 为什么浮点数运算的时候会有精度丢失的风险？\n这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。\nBigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。\nBigDecimal所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigDecimal类进行更加精准的数据计算。\n构造方法：\n常见成员方法：\npublic BigDecimal add(BigDecimal value)\t// 加法运算 public BigDecimal subtract(BigDecimal value)\t// 减法运算 public BigDecimal multiply(BigDecimal value)\t// 乘法运算 public BigDecimal divide(BigDecimal value)\t// 除法运算 如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。\n针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：\nBigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 上述divide方法参数说明：\ndivisor:\t除数对应的BigDecimal对象； scale:\t精确的位数； roundingMode:\t取舍模式； 取舍模式被封装到了RoundingMode这个枚举类中（关于枚举我们后期再做重点讲解），在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个： UP(直接进1) ， FLOOR(直接删除) ， HALF_UP(4舍五入),我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名 后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。\n底层存储方式：\n把数据看成字符串，遍历得到里面的每一个字符，把这些字符在ASCII码表上的值，都存储到数组中。\n13.7.1 BigDecimal常见陷阱 # 13.7.1.1 使用BigDecimal的构造函数传入浮点数 # 其实这个问题我们在使用Float、Double等浮点类型进行计算时，也会经常遇到，如1-0.9f，输出结果是0.100000024。因为 0.9 无法被精确表示为有限位数的二进制小数。在转换为二进制时可能会产生近似值。因此，在进行减法运算时，实际上是对近似值进行计算，而不是对准确的 0.9 进行计算。这导致了精度丢失，最终的计算结果也是一个近似值。因此，输出结果不是准确的 0.1，而是一个近似值。我们在创建BigDecimal对象时，有初始值使用BigDecimal.valueOf()的方式，可以避免出现精度问题。\n@Test public void bigDecimalDemo2(){ BigDecimal bigDecimal1 = new BigDecimal(0.01); BigDecimal bigDecimal2 = BigDecimal.valueOf(0.01); System.out.println(\u0026#34;bigDecimal1 = \u0026#34; + bigDecimal1); System.out.println(\u0026#34;bigDecimal2 = \u0026#34; + bigDecimal2); } Output：\nbigDecimal1 = 0.01000000000000000020816681711721685132943093776702880859375 bigDecimal2 = 0.01 为什么会出现差异？\n在使用new BigDecimal()实际上是将 0.01 转换为二进制近似值，并将其存储为 BigDecimal 对象。因此，结果中存在微小的误差，即输出结果为0.01000000000000000020816681711721685132943093776702880859375。 而BigDecimal.valueOf()不同，其内部是先将double转为String，因此不存在精度问题。\nTIPS:\n使用整数或长整数作为参数构造：\nBigDecimal(int val)：使用一个 int 类型的整数值创建 BigDecimal。\n○BigDecimal(long val)：使用一个 long 类型的整数值创建 BigDecimal。\n使用字符串作为参数构造：\nBigDecimal(String val)：使用一个字符串表示的数值创建 BigDecimal。该字符串可以包含整数部分、小数部分和指数部分。 使用双精度浮点数作为参数构造：\nBigDecimal(double val)：使用一个 double 类型的浮点数值创建 BigDecimal。注意，由于浮点数精度可能丢失，建议使用字符串或其他方法构造 BigDecimal，以避免精度损失问题。 使用基于 BigInteger 的构造方法：\nBigDecimal(BigInteger val)：使用一个 BigInteger 对象来创建 BigDecimal。 13.7.1.2 使用equals()方法进行数值比较 # 日常项目我们是如何进行BigDecimal数值比较呢？使用equals方法还是compareTo方法？如果使用的是equals方法，那就需要注意啦。看一下示例：\nmal bigDecimal1 = new BigDecimal(\u0026#34;0.01\u0026#34;); BigDecimal bigDecimal2 = new BigDecimal(\u0026#34;0.010\u0026#34;); System.out.println(bigDecimal1.equals(bigDecimal2)); System.out.println(bigDecimal1.compareTo(bigDecimal2)); } Output：\nfalse 0 观察结果可以知道使用equals比较结果是不相等的；compareTo的结果为0代表两个数相等；\ncompareTo实现了Comparable接口，比较的是值的大小，返回的值为-1-小于，0-等于，1-大于。 为什么equals返回的是false？\npublic boolean equals(Object x) { if (!(x instanceof BigDecimal)) return false; BigDecimal xDec = (BigDecimal) x; if (x == this) return true; if (scale != xDec.scale) return false; long s = this.intCompact; long xs = xDec.intCompact; if (s != INFLATED) { if (xs == INFLATED) xs = compactValFor(xDec.intVal); return xs == s; } else if (xs != INFLATED) return xs == compactValFor(this.intVal); return this.inflated().equals(xDec.inflated()); } 我们观察equals的实现逻辑可以知道，BigDecimal重写了equals方法，重写后的关键代码：\nif (scale != xDec.scale) return false; 也就是会比较两个数值的精度，精度不同返回false。\n","date":"11 March 2025","externalUrl":null,"permalink":"/posts/1741665094216-%E5%B8%B8%E8%A7%81api%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/","section":"Posts","summary":"","title":"常见API\u0026对象克隆","type":"posts"},{"content":" 时间\u0026amp;包装类 # 1.1 Date类 # java.util.Date类 表示特定的瞬间，精确到毫秒。\npublic Date()：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。\nDate类中的多数方法已经过时，常用的方法有：\npublic long getTime() 把日期对象转换成对应的时间毫秒值。 public void setTime(long time) 把方法参数给定的毫秒值设置给日期对象 1.2 SimpleDateFormat类 # java.text.SimpleDateFormat 是日期/时间格式化类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n格式化：按照指定的格式，把Date对象转换为String对象。 解析：按照指定的格式，把String对象转换为Date对象。 由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\npublic SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。 常用的格式规则为：\n标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。\nDateFormat类的常用方法有：\npublic String format(Date date)：将Date对象格式化为字符串。\npublic Date parse(String source)：将字符串解析为Date对象。\n//1.定义一个字符串表示时间 String str = \u0026#34;2023-11-11 11:11:11\u0026#34;; //2.利用空参构造创建simpleDateFormat对象 // 细节: //创建对象的格式要跟字符串的格式完全一致 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); 1.3 Calendar类 # java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。 有两种方式可以获取GregorianCalendar对象： 直接创建GregorianCalendar对象； 通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象 方法名 说明 public static Calendar getInstance() 获取一个它的子类GregorianCalendar对象。 public int get(int field) 获取某个字段的值。field参数表示获取哪个字段的值，\n可以使用Calender中定义的常量来表示：\nCalendar.YEAR : 年\nCalendar.MONTH ：月\nCalendar.DAY_OF_MONTH：月中的日期\nCalendar.HOUR：小时\nCalendar.MINUTE：分钟\nCalendar.SECOND：秒\nCalendar.DAY_OF_WEEK：星期 public void set(int field,int value) 设置某个字段的值 public void add(int field,int amount) 为某个字段增加/减少指定的值 1.4 JDK8时间相关类 # JDK8时间类类名 作用 ZoneId 时区 Instant 时间戳 ZoneDateTime 带时区的时间 DateTimeFormatter 用于时间的格式化和解析 LocalDate 年、月、日 LocalTime 时、分、秒 LocalDateTime 年、月、日、时、分、秒 Duration 时间间隔（秒，纳，秒） Period 时间间隔（年，月，日） ChronoUnit 时间间隔（所有单位） 1.5 包装类 # Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类。\n包装数据类型‌是Java编程语言中的一个重要概念，用于将基本数据类型（如byte、short、int、long、float、double、char、boolean）封装为对象类型。这样做的主要目的是为了弥补Java作为面向对象语言在处理基本数据类型时的一些不足，确保“一切皆对象”的原则得以实现‌。\n基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer类：\nInteger类概述\n包装一个对象中的原始类型 int 的值\nInteger类构造方法及静态方法\n方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回保存指定String值的 Integer 对象 static string tobinarystring(int i) 得到二进制 static string tooctalstring(int i) 得到八进制 static string toHexstring(int i) 得到十六进制 static int parseInt(string s) 将字符串类型的整数转成int类型的整数 1.5.1 装箱与拆箱 # 基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可）\n基本数值\u0026mdash;-\u0026gt;包装对象\nInteger i = new Integer(4);//使用构造函数函数 Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象\u0026mdash;-\u0026gt;基本数值\nint num = i.intValue(); 自动装箱与自动拆箱：\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。\n如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。\n1.5.2 基本类型与包装类型的区别 # 用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。\n存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。\n占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。\n默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。\n比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。\n为什么说是几乎所有对象实例都存在于堆中呢？ 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。\n基本数据类型存放在栈中是一个常见的误区， 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。\n1.5.3 包装类型的缓存机制 # Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。\nByte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。\n如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。\n所有整型包装类对象之间值的比较，全部使用 equals 方法比较。\n1.5.4 基本类型与字符串之间的转换 # 基本类型转换为String\n转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() String转换成基本类型\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\npublic static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。\n底层原理：\n建议：获取Integer对象的时候不要自己new，而是采取直接赋值或者静态方法valueOf的方式\n因为在实际开发中，-128~127之间的数据，用的比较多。如果每次使用都是new对象，那么太浪费内存了。\n所以，提前把这个范围之内的每一个数据都创建好对象，如果要用到了不会创建新的，而是返回已经创建好的对象。\n1.5.5 int 和 Integer 的区别 # int和Integer之间的区别主要在以下几个方面：\n数据类型：int是Java的基本数据类型，而Integer是int的包装类，属于引用类型。 可空性：int是基本数据类型，它不能为null。而Integer是一个对象，可以为null。 自动装箱与拆箱：int可以直接赋值给Integer，这个过程称为自动装箱；而Integer也可以直接赋值给int，这个过程称为自动拆箱。 性能和内存开销：由于int是基本数据类型，它的值直接存储在栈内存中，占用的空间较小且访问速度快。而Integer是对象，它的值存储在堆内存中，占用的空间相对较大，并且访问速度较慢。因此，频繁使用的整数推荐使用int，不需要使用对象特性时可以避免使用Integer。 总的来说，int是基本数据类型，适用于简单的整数运算和存储，没有对象的特性和可空性。而Integer是int的包装类，可以作为对象使用，具有更多的方法和一些方便的功能，如转换、比较等，但相对会带来一些性能和内存开销。\n","date":"11 March 2025","externalUrl":null,"permalink":"/posts/1741665209773-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%8C%85%E8%A3%85%E7%B1%BB/","section":"Posts","summary":"","title":"时间类\u0026包装类","type":"posts"},{"content":" 正则表达式 # 1.1 正则表达式的概念 # 正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。\n1.2 正则表达式-字符类 # 语法示例： [abc]：代表a或者b，或者c字符中的一个。 [^abc]：代表除a,b,c以外的任何字符。 [a-z]：代表a-z的所有小写字符中的一个。 [A-Z]：代表A-Z的所有大写字符中的一个。 [0-9]：代表0-9之间的某一个数字字符。 [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。 [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 1.3 正则表达式-逻辑运算符 # 语法示例：\n\u0026amp;\u0026amp;：并且 | ：或者 \\ ：转义字符（改变后面那个字符原本的含义，就是把原本的识别改为普通字符，如\u0026quot;\\\u0026quot;\u0026quot;） 1.4 正则表达式-预定义字符 # 语法示例：\n\u0026ldquo;.\u0026rdquo; ： 匹配任何字符。 \u0026ldquo;\\d\u0026rdquo;：任何数字[0-9]的简写； \u0026ldquo;\\D\u0026rdquo;：任何非数字[^0-9]的简写； \u0026ldquo;\\s\u0026rdquo;： 空白字符：[ \\t\\n\\x0B\\f\\r] 的简写 \u0026ldquo;\\S\u0026rdquo;： 非空白字符：[^\\s] 的简写 \u0026ldquo;\\w\u0026rdquo;：单词字符：[a-zA-Z_0-9]的简写 \u0026ldquo;\\W\u0026rdquo;：非单词字符：[^\\w] 1.5 正则表达式-数量词 # 语法示例：\nX? : 0次或1次 X* : 0次到多次 X+ : 1次或多次 X{n} : 恰好n次 X{n,} : 至少n次 X{n,m}: n到m次(n和m都是包含的) 1.6 本地数据爬取 # Pattern：表示正则表达式 Matcher：文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。 在大串中去找符合匹配规则的子串。\n//1.获取正则表达式的对象 Pattern p = Pattern.compile(\u0026#34;Java\\\\d{0,2}\u0026#34;); //2.获取文本匹配器的对象 //拿着m去读取str，找符合p规则的子串 Matcher m = p.matcher(str); //3.利用循环获取 while (m.find()) { String s = m.group(); System.out.println(s); } 1.7 贪婪爬取和非贪婪爬取 # 只写+和表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取 +? 非贪婪匹配 *? 非贪婪匹配 贪婪爬取:在爬取数据的时候尽可能的多获取数据 非贪婪爬取:在爬取数据的时候尽可能的少获取数据 举例： 如果获取数据：ab+ 贪婪爬取获取结果:abbbbbbbbbbbb 非贪婪爬取获取结果:ab 1.8 String的split方法中使用正则表达式 # String类的split()方法原型：\npublic String[] split(String regex) //参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为\u0026#34;分隔符\u0026#34;来切割字符串。 1.9 String类的replaceAll方法中使用正则表达式 # String类的replaceAll()方法原型： public String replaceAll(String regex,String newStr) //参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。 1.10 正则表达式-分组括号( ) # 细节：如何识别组号？\n只看左括号，不看有括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等\n// \\\\组号:表示把第X组的内容再出来用一次 String regex1 = \u0026#34;(.).+\\\\1\u0026#34;; System.out.println(\u0026#34;a123a\u0026#34;.matches(regex1)); 忽略大小写的写法:\n//(?i) ：表示忽略后面数据的大小写 //忽略abc的大小写 String regex = \u0026#34;(?i)abc\u0026#34;; //a需要一模一样，忽略bc的大小写 String regex = \u0026#34;a(?i)bc\u0026#34;; //ac需要一模一样，忽略b的大小写 String regex = \u0026#34;a((?i)b)c\u0026#34;; ","date":"11 March 2025","externalUrl":null,"permalink":"/posts/1741665184380-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","section":"Posts","summary":"","title":"正则表达式","type":"posts"},{"content":" static \u0026amp; 继承 # Java中成员（变量和方法）等是存在属性的，Java通过static关键字来进行区分。static关键字在Java开发非常的重要，对于理解面向对象非常关键。\n关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是属于类的是放在静态区中，没有static修饰的成员变量和方法则是属于对象的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。\n1.1 static关键字 # 1.1.1 定义格式和使用 # static是静态的意思。 static可以修饰成员变量或者修饰方法。\n静态变量及其访问：\n有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为类变量或者静态成员变量。 直接用 类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。\n静态变量是通过类名来访问的，例如StaticVariableExample.staticVar（如果被 private关键字修饰就无法这样访问了）。\n通常情况下，静态变量会被 final 关键字修饰成为常量。\n实例变量及其访问：\n无static修饰的成员变量属于每个对象的， 这个成员变量叫实例变量，之前我们写成员变量就是实例成员变量。\n需要注意的是：实例成员变量属于每个对象，必须创建类的对象才可以访问。\n格式：对象.实例成员变量\n静态方法及其访问：\n有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为类方法或者静态方法。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。\n与静态成员变量一样，静态方法也是直接通过类名.方法名称即可访问。\n实例方法及其访问：\n无static修饰的成员方法属于每个对象的，这个成员方法也叫做实例方法。\n需要注意的是：实例方法是属于每个对象，必须创建类的对象才可以访问。\n1.1.2 静态方法和实例方法有何不同? # 1、调用方式\n在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。\n不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。\n因此，一般建议使用 类名.方法名 的方式来调用静态方法。\n2、访问类成员是否存在限制\n静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。\n1.2 继承 # 假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。\n其中，多个类可以称为子类，单独被继承的那一个类称为父类、超类（superclass）或者基类。\n1.2.1 继承的含义 # 继承描述的是事物之间的所属关系，这种关系是：is-a 的关系。父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。\n继承：就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。\n不同类型的对象，相互之间经常有一定数量的共同点，但同时，每一个对象还定义了额外的特性使得他们与众不同。==继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。==\n子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。\n子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n子类可以用自己的方式实现父类的方法（方法重写）。\n继承的好处：\n通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 使类与类之间产生了关系。 1.2.2 继承的格式 # 通过 extends 关键字，可以声明一个子类继承另外一个父类。\nclass 父类 { ... } class 子类 extends 父类 { ... } Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。\n1.2.3 子类不能继承的内容 # 子类不能继承父类的构造方法。\n值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。\n1.2.4 继承后的特点—成员变量 # 成员变量不重名:\n如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。\n成员变量重名:\n如果子类父类中出现重名的成员变量，这时的访问是有影响的。子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量,我们可以使用super关键字。\nsuper访问父类成员变量:\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super 关键字，修饰父类成员变量，类似于之前学过的 this 。\nsuper代表的是父类对象的引用，this代表的是当前对象的引用。\nFu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么访问父类的私有成员变量就可以使用在父类中提供公共的getXxx方法和setXxx方法。\n1.2.5 继承后的特点——成员方法 # 成员方法不重名：\n如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。\n成员方法重名:\n如果子类父类中出现重名的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。\n1.2.6 方法重写 # 1.2.6.1 概念 # 方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。\n发生在子父类之间的关系。子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方法。\n重载和重写有什么区别？\n重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，也就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\n重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法\n重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n《Java 核心技术》这本书是这样介绍重载的：\n如果多个方法(比如 StringBuilder 的构造方法)有相同的名字、不同的参数， 便产生了重载。\n编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。\nJava 允许重载任何方法， 而不只是构造器方法。\n重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。\n区别点 重载方法 重写方法 发生范围 同一个类 子类 参数列表 必须修改 一定不能修改 返回类型 可修改 子类方法返回值类型应比父类方法返回值类型更小或相等 异常 可修改 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 方法的重写要遵循“两同两小一大”\n“两同”即方法名相同、形参列表相同；\n“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\n“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\n关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的\n1.2.6.2 @Override重写注解 # @Override:注解，重写注解校验\n这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。\n建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错。\n注意事项：\n方法重写是发生在子父类之间的关系。 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 1.2.6.3 构造器是否可以被重写 # **构造器在Java中是一种特殊的方法，用于创建和初始化对象。**与其他普通方法不同，构造器的名称必须与类名一致，并且没有返回类型。 **在Java中，构造器不能被直接重写。**子类无法定义与父类相同名称和参数的构造器。这是因为构造器是用于创建对象并初始化其状态的特殊方法，它与类的实例化密切相关。如果允许子类重写构造器，那么可能会导致对象的创建和初始化过程出现混乱，破坏了类的结构和设计原则。 然而，**子类可以通过调用父类的构造器来完成对继承的父类的初始化操作。**在子类的构造器中可以使用关键字super来调用父类的构造器，并传递相应的参数。这样可以确保父类的构造器得到正确地执行，从而完成对父类属性的初始化。 总结起来，构造器本身不能被重写，但子类可以通过调用父类的构造器来实现对父类的初始化操作。\n1.2.7 继承后的特点—构造方法 # 构造方法的定义格式和作用：\n构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（先有爸爸，才能有儿子） 继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法\n子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。 子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。 1.2.8 super(\u0026hellip;)和this(\u0026hellip;) # 子类有参数构造方法只是初始化了自己对象中的成员变量，而父类中的成员变量依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(\u0026hellip;)去调用父类构造方法，以便初始化继承自父类对象的成员变量。\n关于super与this的例子：\nclass Person { private String name =\u0026#34;凤姐\u0026#34;; private int age = 20; public Person() { System.out.println(\u0026#34;父类无参\u0026#34;); } public Person(String name , int age){ this.name = name ; this.age = age ; } // getter/setter省略 } class Student extends Person { private double score = 100; public Student() { //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行 System.out.println(\u0026#34;子类无参\u0026#34;); } public Student(String name ， int age，double score) { super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age this.score = score; System.out.println(\u0026#34;子类有参\u0026#34;); } // getter/setter省略 } public class Demo07 { public static void main(String[] args) { // 调用子类有参数构造方法 Student s2 = new Student(\u0026#34;张三\u0026#34;，20，99); System.out.println(s2.getScore()); // 99 System.out.println(s2.getName()); // 输出 张三 System.out.println(s2.getAge()); // 输出 20 } } 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。\nsuper() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。\nsuper(..)是根据参数去确定调用父类哪个构造方法的。\n1.2.8.1 super(…)案例图解 # 父类空间优先于子类对象产生\n在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：\n1.2.8.2 this(\u0026hellip;)用法演示 # this(\u0026hellip;)\n默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。 为了借用其他构造方法的功能。 1.2.9 继承的特点 # Java只支持单继承，不支持多继承。\n一个类可以有多个子类。\n可以多层继承。\n顶层父类是Object类。所有的类默认继承Object，作为父类。\n关于不支持多继承：\n==Java不直接支持多继承，即一个类不能同时继承多个父类。==这是由设计上的考虑和语言特性决定的。 Java中选择了单继承的设计，主要出于以下几个原因：\n继承的复杂性：多继承会引入菱形继承等复杂性问题。当一个类同时继承自多个父类时，可能会出现命名冲突、方法重复实现等问题，导致代码难以理解和维护。 接口的存在：Java提供了接口（Interface）的概念来解决多继承的问题。接口允许一个类实现多个接口，从而达到类似多继承的效果。接口与类的分离可以降低代码的耦合度，并且使得类的设计更加灵活和可扩展。 单一职责原则：Java鼓励使用组合而非继承的方式，遵循设计原则中的单一职责原则。通过将功能划分为独立的类，然后在需要时进行组合，可以实现更灵活、可复用的代码结构，提高代码的可维护性。 尽管Java不支持直接的多继承，**但可以使用接口或抽象类等方式来模拟部分多继承的功能。**接口提供了一种更灵活、更安全的多继承方式，允许类实现多个接口并获得各个接口的方法声明，同时避免了多继承的复杂性问题。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323987049-java-static%E7%BB%A7%E6%89%BF/","section":"Posts","summary":"","title":"java static\u0026继承","type":"posts"},{"content":" Java基础概念 # 1.1 注释 # 注释是对代码的解释和说明文字。\njava中的注释分为三种：单行注释、多行注释、文档注释。\n注释的内容不会参与编译和运行，仅仅是对代码的解释说明。\n单行注释：通常用于解释方法内某单行代码的作用。 多行注释：通常用于解释一段代码的作用。 文档注释：通常用于生成 Java 开发文档。 1.2 关键字 # 有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，==关键字是被赋予特殊含义的标识符== 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。\n当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。\nJava 语言中的关键字：\n分类 关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile enum 程序控制 break continue return do while if else for instanceof switch case default assert 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short 变量引用 super this void 保留字 goto const Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。\ndefault 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。\n在程序控制中，当在 switch 中匹配不到任何情况时，可以使用 default 来编写默认匹配的情况。 在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 default 关键字来定义一个方法的默认实现。 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 default，但是这个修饰符加上了就会报错。 注意：虽然 true, false, 和 null 看起来像关键字但实际上他们是字面值，同时也不可以作为标识符来使用。\n官方文档：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\n1.3 Class # 表示定义一个类，创建一个类。\n==类：Java项目最基本的组成单元，一个完整的java项目有可能会有成千上万个类来组成。==\nclass后买你跟随的就是这个类的名字，简称类名。\n在类名后面会有一对大括号，表示这个类的内容。\npublic class HelloWorld{ } 1.4 字面量 # 作用：告诉程序员，数据在程序中的书写格式，用于表达源代码中一个固定值的表示法。\n字面量类型 说明 程序中的写法 整数 不带小数的数字 666，-88 小数 带小数的数字 13.14，-5.21 字符 必须使用单引号，有且仅能一个字符 ‘A’，‘0’， ‘我’ 字符串 必须使用双引号，内容可有可无 “HelloWorld”，“黑马程序员” 布尔值 布尔值，表示真假，只有两个值：true，false true 、false 空值 一个特殊的值，空值 值是：null 1.5 变量 # ==变量是存储数据的基本单位，它允许程序员在代码中使用易于记忆的名称来代表内存地址。==\n变量是在程序中临时存储数据的容器，但是这个容器中只能存一个值。\n变量的定义格式：\n数据类型 变量名=数据值；（int a =0;）\n数据类型：限定了变量当中能存储什么类型的数据。\n变量名：其实就是这个容器的名字。\n数据值：真正存储在容器中的数据。\n分号：表示语句的结束，就跟以前写作文时候的句号是一样的。\n变量的注意事项：\n变量名不能重复\n**在一条语句中，可以定义多个变量。**但是这种方式影响代码的阅读，所以了解一下即可。\nint a,b,c; 变量在使用之前必须要赋值。\n1.6 数据类型 # 1.6.1 基本数据类型 # java语言数据类型分为：**引用数据类型和基本数据类型。**除了基本数据类型的数据均称为引用数据类型。\n基本数据类型的四类八种：\n数据类型 关键字 内存占用 取值范围 整数 byte 1 负的2的7次方 ~ 2的7次方-1(-128~127) short 2 负的2的15次方 ~ 2的15次方-1(-32768~32767) int 4 负的2的31次方 ~ 2的31次方-1 long 8 负的2的63次方 ~ 2的63次方-1 浮点数 float 4 1.401298e-45 ~ 3.402823e+38 double 8 4.9000000e-324 ~ 1.797693e+308 字符 char 2 0-65535 布尔 boolean 1 true，false ​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\n在java中整数默认是int类型，浮点数默认是double类型。\nbyte类型的取值范围：-128 ~ 127\nint类型的大概取值范围：-21亿多 ~ 21亿多\n整数类型和小数类型的取值范围大小关系：\n​\tdouble \u0026gt; float \u0026gt; long \u0026gt; int \u0026gt; short \u0026gt; byte\n如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀，否则将作为整型解析。（大小写都可以，建议大写。）\n如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀，否则将无法通过编译。（大小写都可以）\n对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\n另外，**Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。**这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。\n1.6.2 char型变量能存贮一个中文汉字吗 # 在Java中，==char类型是用来表示单个字符的数据类型，它采用Unicode编码，可以存储各种字符，包括中文汉字。== 由于Unicode编码使用16位来表示一个字符，char类型占用2个字节的内存空间。而**中文汉字通常使用UTF-8编码，一个中文字符占用3个字节的存储空间。**因此，将一个中文汉字直接赋值给char类型的变量可能会出现问题，因为无法完整地表示一个中文字符。 如果要在char类型中表示一个中文汉字，可以使用Unicode转义序列。\\u后面跟着表示字符的四位十六进制值，通过转义序列可以正确地表示一个中文汉字。例如，字符 \u0026lsquo;中\u0026rsquo; 的Unicode编码为\u0026rsquo;\\u4e2d\u0026rsquo;，我们可以使用char类型变量去存储这个中文汉字：char ch = \u0026lsquo;\\u4e2d\u0026rsquo;;。 需要注意的是，对于一个完整的中文字符，建议使用更适合的数据类型，如String类型来存储。 char类型主要用于表示单个字符，而不是用于存储复杂字符集合。\n1.7 标识符 # 在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 标识符 。简单来说， ==标识符就是一个名字== 。\n1.7.1硬性要求 # 必须要这么做，否则代码会报错。\n必须由数字、字母、下划线_、美元符号$组成。 数字不能开头 不能是关键字 区分大小写的。 1.7.2 软件建议 # 1.7.2.1 小驼峰命名法 # 适用于变量名和方法名\n如果是一个单词，那么全部小写，比如：name\n如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge\n1.7.2.2 大驼峰命名法 # 适用于类名\n如果是一个单词，那么首字母大写。比如：Demo、Test。\n如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld\n不管起什么名字，都要做到见名知意。\n1.7.2.3阿里巴巴命名规范细节： # 尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。\n正确：alibaba、hangzhou、nanjing\n错误：jiage、dazhe\n平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。\n错误：_name\n正确：name\n1.8 层级结构 # 结构分类\nproject（项目、工程） module（模块） package（包） class（类） 结构介绍\nproject（项目、工程）\n​\t淘宝、京东、黑马程序员网站都属于一个个项目，IDEA中就是一个个的Project。\nmodule（模块）\n​\t在一个项目中，可以存放多个模块，**不同的模块可以存放项目中不同的业务功能代码。**为了更好的管理代码，我们会把代码分别放在多个模块中存放。\npackage（包）\n​\t一个模块中又有很多的业务，为了把这些业务区分的更加清楚，就会用包来管理这些不同的业务。\nclass（类）\n​\t就是真正写代码的地方。Java项目最基本的组成单元。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323825874-java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","section":"Posts","summary":"","title":"java 基础概念","type":"posts"},{"content":" 多态\u0026amp;包\u0026amp;权限修饰符\u0026amp;final # 1.1 多态 # 多态是继封装、继承之后，面向对象的第三大特性。\n多态是出现在继承或者实现关系中的。\n==顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。==\n多态体现的格式：\n父类类型 变量名 = new 子类/实现类构造器; 变量名.方法名(); 多态的特点：\n对象类型和引用类型之间具有继承（类）/实现（接口）的关系；（前提） 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。 多态的使用场景：\n如果没有多态，带参数的方法只能传递一种固定的参数，其他相近类型的参数想要调用这个方法就必须再定义一次，而使用多态，我们就可以将方法的形参定义为共同的父类。\n注意：\n当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象。 而且多态还可以根据传递的不同对象来调用不同类中的方法。 1.1.1 多态的定义和前提 # 多态： 是指同一行为，具有多个不同表现形式。\n前提【重点】\n有继承或者实现关系\n方法的重写【意义体现：不重写，无意义】\n父类引用指向子类对象【格式体现】\n父类类型：指子类对象继承的父类类型，或者实现的父接口类型。\n1.1.2 多态的运行特点 # 调用成员变量时：编译看左边，运行看左边\n调用成员方法时：编译看左边，运行看右边\n1.1.3 多态的弊端 # 我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了。\n1.1.4 引用类型转换 # 转型原因：\n​\t多态的写法无法访问子类独有功能。\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。\n1.1.4.1 向上转型（自动转换） # 向上转型：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 原因是：父类类型相对与子类来说是大范围的类型，所以子类范围小可以直接自动转型给父类类型的变量。\n1.1.4.2 向下转型（强制转换） # 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\n使用格式：\n子类类型 变量名 = (子类类型) 父类变量名; 如:Aniaml a = new Cat(); Cat c =(Cat) a; 子类之间不能互相转换，会出现ClassCastException异常。\n1.1.4.3 instanceof 关键字 # 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：\n变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。 如果变量不属于该数据类型或者其子类类型，返回false。 JDK14的时候提出了新特性，把判断和强转合并成了一行：\n//新特性 //先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d //如果不是，则不强转，结果直接是false if(a instanceof Dog d){ d.lookHome(); }else if(a instanceof Cat c){ c.catchMouse(); }else{ System.out.println(\u0026#34;没有这个类型，无法转换\u0026#34;); } 1.2 包 # 包在操作系统中其实就是一个文件夹。包是用来分门别类的管理技术，不同的技术类放在不同的包下，方便管理和维护。\n包名一般是公司域名的倒写。例如：黑马是www.itheima.com,包名就可以定义成com.itheima.技术名称。 包名必须用”.“连接。 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。 什么时候需要导包？\n​\t情况一：在使用Java中提供的非核心包中的类时\n​\t情况二：使用自己写的其他包中的类时\n什么时候不需要导包？\n​\t情况一：在使用Java核心包（java.lang）中的类时\n​\t情况二：在使用自己写的同一个包中的类时\n使用不同包下的相同类时，我们需要使用全类名的形式：\n//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference com.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student(); 1.3 权限修饰符 # 在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。\npublic：公共的，所有地方都可以访问。\nprotected：本类 ，本包，其他包中的子类都可以访问。\n默认（没有修饰符）：本类 ，本包可以访问。\n注：默认是空着不写，会由系统自动添加default关键字，如果手动写了default会报错\nprivate：私有的，当前类可以访问。 public \u0026gt; protected \u0026gt; 默认 \u0026gt; private\n不同权限的访问能力：\npublic protected 默认 private 同一类中 √ √ √ √ 同一包中的类 √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。\n编写代码时，如果没有特殊的考虑，建议这样使用权限：\n成员变量使用private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用public ，方便调用方法。 小贴士：不加权限修饰符，就是默认权限\n1.4 final 关键字 # 有一个方法我不想别人去改写里面内容，那么Java提供了final 关键字，表示修饰的内容不可变。\nfinal： 不可改变，最终的含义。可以用于修饰类、方法和变量。\n类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 局部变量（就是写在方法内的）被final修饰后，只能赋值一次，不能再更改。\n成员变量（就是类内方法外）涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：\n显示初始化(在定义成员变量的时候立马赋值)（常用）； public class Student { final int num = 10; } 构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。\n注意：每个构造方法中都要赋值一次！\npublic class Student { final int num = 10; final int num2; public Student() { this.num2 = 20; // this.num2 = 20; } public Student(String name) { this.num2 = 20; // this.num2 = 20; } } 被final修饰的常量名称，一般都有书写规范，所有字母都大写。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741324029063-java-%E5%A4%9A%E6%80%81%E5%8C%85%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6final/","section":"Posts","summary":"","title":"java 多态\u0026包\u0026权限修饰符\u0026final","type":"posts"},{"content":" 字符串 # 1.1 String类 # String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，**Java 程序中所有的双引号字符串，都是 String 类的对象。**String 类在 java.lang 包下，所以使用的时候不需要导包！\nString类的特点：\n==字符串不可变==，它们的值在创建后不能被更改 虽然 String 的值是不可变的，但是它们可以被共享 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] ) 字符型常量和字符串常量的区别：\n**形式：**字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符。 **含义：**字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放的位置）。 **占内存大小：**字符常量只占2个字节；字符串常量占若干个字节。 String为什么是不可变的？\nString 类中使用 final 关键字修饰字符数组来保存字符串，所以String 对象是不可变的。\npublic final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { private final char value[]; //... } 修正：我们知道被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。\nString 真正不可变有下面几点原因：\n保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?\n新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，byte 占一个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间。\nJDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。\n1.1.1 String类的构造方法 # 常用的构造方法\n方法名 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) 根据字符数组的内容，来创建字符串对象 public String(byte[] bys) 根据字节数组的内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 创建字符串对象两种方式的区别：\nJava中字符串可以通过两种方式创建：==使用字符串字面量直接赋值给变量或使用关键字new创建一个新的String对象。==它们之间有以下区别：\n使用字符串字面量赋值给变量时，Java会使用字符串常量池来管理字符串对象，可以提高性能和节省内存。而使用new String创建的字符串对象则在堆内存中独立分配内存空间，每次调用都会创建一个新的对象，因此内存消耗更大。 使用字符串字面量赋值给变量的字符串是不可变的，即不能改变其内容。而使用new String创建的字符串对象是可变的，可以通过调用方法或者使用赋值运算符修改其内容。 使用字符串字面量赋值给变量的字符串比较时，如果多个变量引用相同的字符串字面量，则它们实际上引用的是同一个对象，因此比较它们的引用时将返回true。而使用new String创建的字符串对象，即使内容相同，它们也是不同的对象，因此比较它们的引用时将返回false。 1.1.2 字符串的比较 # ==号的作用：\n比较基本数据类型：比较的是具体的值 比较引用数据类型：比较的是对象地址值 equals方法的作用：\n方法介绍：\npublic boolean equals(String s) 比较两个字符串内容是否相同、区分大小写(不是地址值) 注：equals方法本身在比较引用数据类型时比较的也是对象地址值，但是String类重写了equals方法，所以我们用String类带的equals方法比较字符串时比较的是字符串内容。\n1.1.3 字符串常量池的作用 # 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n==String s1 = new String(\u0026ldquo;abc\u0026rdquo;);这句话创建了几个字符串对象？==\n先说答案：会创建 1 或 2 个字符串对象。\n字符串常量池中不存在 \u0026ldquo;abc\u0026rdquo;：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 \u0026ldquo;abc\u0026rdquo; 进行初始化。 字符串常量池中已存在 \u0026ldquo;abc\u0026rdquo;：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 \u0026ldquo;abc\u0026rdquo; 进行初始化。 1.1.4 String类能被继承吗 # 在Java中，String类是被final关键字修饰的，即不可继承。final关键字表示一个类不允许被其他类继承，也就是说，String类不能被任何其他类继承。 这是因为String类具有不可变性和安全性，这些特性可以防止一些潜在的问题，如字符串池中的重用和安全性漏洞。 如果String类能被继承，子类有可能修改原字符串的值，这将破坏字符串对象的不可变性。此外，String类的方法和变量都被设计成private、final和static的，这说明它们不能被重写或隐藏。如果String类可以被继承，这些设计决策将被打破，可能产生更多的问题。 因此，尽管我们不能从String类派生出新的子类，但我们可以使用String类提供的方法来操作和处理字符串。例如，我们可以使用String类的concat()方法连接两个字符串，或使用indexOf()方法查找子串在字符串中的位置等。String类已经包含了大量的方法，可以满足大多数字符串操作的需求。\n1.2 StringBuilder # StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。\n当我们在拼接字符串和反转字符串的时候会使用到\n关于StringBuilder的添加、反转与打印：\npublic class StringBuilderDemo3 { public static void main(String[] args) { //1.创建对象 StringBuilder sb = new StringBuilder(\u0026#34;abc\u0026#34;); //2.添加元素 /*sb.append(1); sb.append(2.3); sb.append(true);*/ //反转 sb.reverse(); //获取长度 int len = sb.length(); System.out.println(len); //打印 //普及： //因为StringBuilder是Java已经写好的类 //java在底层对他做了一些特殊处理。 //打印对象不是地址值而是属性值。 System.out.println(sb); } } 字符串拼接用 “ + ” 还是 StringBuilder ？\nJava 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。\n字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。\n不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。\nStringBuilder 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象。如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。\n在 JDK 9 中，字符串相加“+”改为用动态方法 makeConcatWithConstants() 来实现，通过提前分配空间从而减少了部分临时对象的创建。然而这种优化主要针对简单的字符串拼接，如： a+b+c 。对于循环中的大量拼接操作，仍然会逐个动态分配内存（类似于两个两个 append 的概念），并不如手动使用 StringBuilder 来进行拼接效率高。\n1.3 StringBuffer（比较分析） # 可变性\nStringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。\n线程安全性\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n性能\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n对于三者使用的总结：\n操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 1.4 StringJoiner # StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 JDK8出现的 基本使用：\n//1.创建一个对象，并指定中间的间隔符号 StringJoiner sj = new StringJoiner(\u0026#34;---\u0026#34;); //2.添加元素 sj.add(\u0026#34;aaa\u0026#34;).add(\u0026#34;bbb\u0026#34;).add(\u0026#34;ccc\u0026#34;); //3.打印结果 System.out.println(sj);//aaa---bbb---ccc //1.创建对象 StringJoiner sj = new StringJoiner(\u0026#34;, \u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;); //2.添加元素 sj.add(\u0026#34;aaa\u0026#34;).add(\u0026#34;bbb\u0026#34;).add(\u0026#34;ccc\u0026#34;); int len = sj.length(); System.out.println(len);//15 //3.打印 System.out.println(sj);//[aaa, bbb, ccc] String str = sj.toString(); System.out.println(str);//[aaa, bbb, ccc] 1.5 关于字符串的扩展 # 字符串存储的内存原理\nString s = “abc”；直接赋值\n特点：\n​\t此时字符串abc是存在字符串常量池中的。\n​\t先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。\n所以，直接赋值的方式，代码简单，而且节约内存。\nnew出来的字符串\n看到new关键字，一定是在堆里面开辟了一个小空间。\nString s1 = new String（“abc”）；\nString s2 = “abc”；\ns1记录的是new出来的，在堆里面的地址值。\ns2是直接赋值的，所以记录的是字符串常量池中的地址值。\n==号比较的到底是什么？\n如果比较的是基本数据类型：比的是具体的数值是否相等。\n如果比较的是引用数据类型：比的是地址值是否相等。\n结论：==只能用于比较基本数据类型。不能比较引用数据类型。\n1.6 String#intern方法（了解） # String.intern() 是一个 native (本地) 方法，用来处理字符串常量池中的字符串对象引用。它的工作流程可以概括为以下两种情况：\n常量池中已有相同内容的字符串对象：如果字符串常量池中已经有一个与调用 intern() 方法的字符串内容相同的 String 对象，intern() 方法会直接返回常量池中该对象的引用。\n常量池中没有相同内容的字符串对象：如果字符串常量池中还没有一个与调用 intern() 方法的字符串内容相同的对象，intern() 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。\n代码示例：\npublic class StringInternExample { public static void main(String[] args) { String s1 = new String(\u0026#34;example\u0026#34;); String s2 = \u0026#34;example\u0026#34;; String s3 = s1.intern(); System.out.println(s1 == s2); // 输出 false System.out.println(s2 == s3); // 输出 true } } 总结：\nintern() 方法的主要作用是确保字符串引用在常量池中的唯一性。 当调用 intern() 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。 1.7 String类型的变量和常量做“ + ”运算时发生了什么？ # 先来看字符串不加 final 关键字拼接的情况（JDK1.8）：\nString str1 = \u0026#34;str\u0026#34;; String str2 = \u0026#34;ing\u0026#34;; String str3 = \u0026#34;str\u0026#34; + \u0026#34;ing\u0026#34;; String str4 = str1 + str2; String str5 = \u0026#34;string\u0026#34;; System.out.println(str3 == str4);//false System.out.println(str3 == str5);//true System.out.println(str4 == str5);//false 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。\n在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。\n对于 String str3 = \u0026quot;str\u0026quot; + \u0026quot;ing\u0026quot;; 编译器会给你优化成 String str3 = \u0026quot;string\u0026quot;; 。\n并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：\n基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。 final 修饰的基本数据类型和字符串变量 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（\u0026laquo;、\u0026raquo;、\u0026raquo;\u0026gt; ） 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。\n不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。\n示例代码：\nfinal String str1 = \u0026#34;str\u0026#34;; final String str2 = \u0026#34;ing\u0026#34;; // 下面两个表达式其实是等价的 String c = \u0026#34;str\u0026#34; + \u0026#34;ing\u0026#34;;// 常量池中的对象 String d = str1 + str2; // 常量池中的对象 System.out.println(c == d);// true 被 final 关键字修饰之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。\n如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。\n1.8 Java中变量和常量的区别 # 在java中，变量和常量是两个不同的概念，他们有以下几点区别：\n可变性：\n变量是可以被修改的，其值可以在程序的执行过程中改变。\n常量是不可被修改的，其值在定义后不能再被改变。\n声明与赋值：\n变量需要先声明，并可以在声明后进行赋值。声明时需要指定变量的类型 ==常量在定义时需要使用final关键字进行修饰== 内存空间：\n变量在内存中占用一块存储空间，可以改变这个存储空间中的值。 常量通常会被编译器在编译时直接替换为对应的值，所以在内存中不会为常量分配额外的存储空间，而是直接使用常量的值。 使用场景：\n变量用于存储会发生变化的数据，例如计数器、临时结果等，在程序的执行过程中可以根据需要改变其值。 常量用于表示不可变的数据，例如数学常数、配置项等，在程序中通常希望保持其固定的值，避免误操作导致值的变化。 总结来说，变量是可变的并且需要先声明后赋值，而常量是不可变的并且需要在定义时进行初始化赋值。变量占用内存空间且值可以改变，而常量通常会被编译器直接替换为对应的值，不占用额外的内存空间。变量用于存储会发生变化的数据，常量用于表示不可变的数据。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323961758-java-%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Posts","summary":"","title":"java 字符串","type":"posts"},{"content":" 循环高级 # 1.1 无线循环 # 概念：\n​\t又叫死循环。循环一直停不下来。\nfor格式：\nfor(;;){ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); } 解释：\n初始化语句可以空着不写，表示循环之前不定义任何的控制变量。\n条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。\n条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。\nwhile格式：\nwhile(true){ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); } 解释：\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\ndo\u0026hellip;while格式：\ndo{ System.out.println(\u0026#34;循环执行一直在打印内容\u0026#34;); }while(true); 解释：\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\n无限循环的注意事项：\n最为常用的格式：while 无限循环下面不能再写其他代码了，因为永远执行不到。 1.2 条件控制语句 # break continue break:\n​\t不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。\ncontinue:\n​\t不能单独存在的。只能存在于循环当中。\n​\t表示：跳过本次循环，继续执行下次循环。\n1.3 continue \u0026amp; break \u0026amp; return 的区别 # 在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：\ncontinue：指跳出当前的这一次循环，继续下一次循环。 break：指跳出整个循环体，继续执行循环下面的语句。 return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：\nreturn;：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value;：return 一个特定值，用于有返回值函数的方法 1.4 for-each 与常规for循环 # for-each循环形式如下：\nfor(element_type element : collection){ //在此处执行针对 element 的操作 } 示例：\npublic class Main { public static void main(Stringl args[]){ int a[] = new int[]{1,2,3,4,5};\tfor (int i : a){ System.out.println( i + \u0026#34;、\u0026#34;);\t} } } 在Java中，for-each循环（也称为增强型for循环）和常规for循环有一些差异，包括它们在执行效率上的区别。下面是它们之间的一些比较：\n执行效率：在大多数情况下，常规for循环的执行效率比for-each循环高。这是因为for-each循环需要额外的步骤来获取集合或数组中的元素，而常规for循环可以直接通过索引访问元素，避免了额外的开销。 可变性：常规for循环具有更大的灵活性，可以在循环过程中修改计数器，从而控制循环的行为。而for-each循环是只读的，不能在循环过程中修改集合或数组的元素。 代码简洁性：for-each循环通常比常规for循环更加简洁易读，尤其在遍历集合或数组时。使用for-each循环可以减少迭代器或索引变量的声明和管理，使代码更加清晰。 尽管常规for循环在执行效率上可能更高，但在大多数实际情况下，两者之间的性能差异不会对程序性能产生显著影响。因此，根据具体的使用场景和代码可读性的需求，可以选择使用for-each循环或常规for循环。在只需要遍历集合或数组而不修改其中元素的情况下，for-each循环是一个方便且简洁的选择。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323895545-java-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7/","section":"Posts","summary":"","title":"java 循环高级","type":"posts"},{"content":" 抽象类\u0026amp;接口\u0026amp;内部类 # 1.1 抽象类 # ==我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。==\n抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 1.1.1 abstract抽象方法 # 使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。\n定义格式：\n修饰符 abstract 返回值类型 方法名 (参数列表)； 1.1.2 抽象类 # 如果一个类包含抽象方法，那么该类必须是抽象类。注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。\n定义格式：\nabstract class 类名字 { } 要求：继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。\n此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。\n1.1.3 抽象类的特征 # 抽象类的特征总结起来可以说是 有得有失\n有得：抽象类得到了拥有抽象方法的能力。\n有失：==抽象类失去了创建对象的能力。==\n其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。\n抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。\n理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\n理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。\n抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。\n抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。\n理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。\n抽象类存在的意义是为了被子类继承。\n理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。\n1.2 接口 # 接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的。\n定义格式：\n//接口的定义格式： interface 接口名称{ // 抽象方法 } // 接口的声明：interface // 接口名称：首字母大写，满足“驼峰模式” 在JDK7，包括JDK7之前，接口中的只有包含：抽象方法和常量\n1.2.1 接口和抽象类的比较 # 接口和抽象类的共同点：\n实例化：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。 抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。 接口和抽象类的区别：\n设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。\n继承和实现：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。\n成员变量：接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。\n方法：\nJava 8 之前，接口中的方法默认是 public abstract ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。\n抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。\n在 Java 8 及以上版本中，接口引入了新的方法类型：default 方法、static 方法和 private 方法。这些方法让接口的使用更加灵活。\nJava 8 引入的default 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。\nJava 8 引入的static 方法无法在实现类中被覆盖，只能通过接口名直接调用（ MyInterface.staticMethod()），类似于类中的静态方法。static 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。\nJava 9 允许在接口中使用 private 方法。private方法可以用于在接口内部共享代码，不对外暴露。\n1.2.2 抽象方法 # 注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！ 按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。\n1.2.3 常量 # 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。\n1.2.4 案例演示 # public interface InterF { // 抽象方法！ // public abstract void run(); void run(); // public abstract String getName(); String getName(); // public abstract int add(int a , int b); int add(int a , int b); // 它的最终写法是： // public static final int AGE = 12 ; int AGE = 12; //常量 String SCHOOL_NAME = \u0026#34;黑马程序员\u0026#34;; } 1.2.5 接口的实现 # 类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。\n/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/ class 类名 implements 接口1,接口2,接口3...{ } 类实现接口的要求和意义:\n必须重写实现的全部接口中所有抽象方法。 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 类与接口之间的关系是多实现的，一个类可以同时实现多个接口。\nJava中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：\n类与接口是实现关系\n接口与接口是继承关系\n接口继承接口就是把其他接口的抽象方法与本接口进行了合并，关键字是extends\n1.3 内部类 # 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。可以把内部类理解成寄生，外部类理解成宿主。\n一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用\n人里面有一颗心脏。 汽车内部有一个发动机。 为了实现更好的封装性。 1.3.1 内部类的分类 # 按定义的位置来分\n成员内部类，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类) {定义在一个类的内部，并且不是静态的。成员内部类可以访问外部类的所有成员，包括私有成员。在创建内部类对象时，需要先创建外部类对象，然后通过外部类对象来创建内部类对象。} 静态内部类，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类) {定义在一个类的内部，并且是静态的。与成员内部类不同，静态内部类不能访问外部类的非静态成员，但可以访问外部类的静态成员。在创建静态内部类对象时，不需要先创建外部类对象，可以直接通过类名来创建。} 局部内部类，类定义在方法内 {定义在一个方法或作用域块中的类，它的作用域被限定在方法或作用域块中。局部内部类可以访问外部方法或作用域块中的 final 变量和参数。} 匿名内部类，没有名字的内部类，可以在方法中，也可以在类中方法外。 {没有定义名称的内部类，通常用于创建实现某个接口或继承某个类的对象。匿名内部类会在定义时立即创建对象，因此通常用于简单的情况，而不用于复杂的类结构。} 成员内部类特点：\n无static修饰的内部类，属于外部类对象的。 宿主：外部类对象。 内部类的使用格式：\n外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类 获取成员内部类对象的两种方式：\n方式一：外部直接创建成员内部类的对象\n外部类.内部类 变量 = new 外部类（）.new 内部类（）; 方式二：在外部类中定义一个方法提供内部类的对象\n案例演示\n方式一： public class Test { public static void main(String[] args) { // 宿主：外部类对象。 // Outer out = new Outer(); // 创建内部类对象。 Outer.Inner oi = new Outer().new Inner(); oi.method(); } } class Outer { // 成员内部类，属于外部类对象的。 // 拓展：成员内部类不能定义静态成员。 public class Inner{ // 这里面的东西与类是完全一样的。 public void method(){ System.out.println(\u0026#34;内部类中的方法被调用了\u0026#34;); } } } 方式二： public class Outer { String name; private class Inner{ static int a = 10; } public Inner getInstance(){ return new Inner(); } } public class Test { public static void main(String[] args) { Outer o = new Outer(); System.out.println(o.getInstance()); } } 编写成员内部类的注意点：\n成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图） 详解：\n​\t内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象\n​\t被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象\n​\t内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。\n​\t内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。\n成员内部类内存图：\n1.3.2 静态内部类 # 静态内部类是一种特殊的成员内部类。 有static修饰，属于外部类本身的。 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。 拓展1:静态内部类可以直接访问外部类的静态成员。 拓展2:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。 拓展3:静态内部类中没有银行的Outer.this。 内部类的使用格式：\n外部类.内部类。 静态内部类对象的创建格式：\n外部类.内部类 变量 = new 外部类.内部类构造器; 调用方法的格式：\n调用非静态方法的格式：先创建对象，用对象调用 调用静态方法的格式：外部类名.内部类名.方法名(); 1.3.3 局部内部类 # 局部内部类 ：定义在方法中的类。\n1.3.4 匿名内部类 # 匿名内部类 ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。\n格式：\nnew 类名或者接口名() { 重写方法; }; 包含了：\n继承或者实现关系\n方法重写\n创建对象\n所以从语法上来讲，这个整体其实是匿名内部类对象\n实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用\n是为了简化代码。\n之前我们使用接口时，似乎得做如下几步操作：\n定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。\n匿名内部类必须继承一个父类或者实现一个父接口。\n匿名内部类格式\nnew 父类名或者接口名(){ // 方法重写 @Override public void method() { // 执行语句 } }; 匿名内部类特点\n定义一个没有名字的内部类 这个类实现了父类，或者父类接口 匿名内部类会创建这个没有名字的类的对象 1.3.5 静态内部类与非静态内部类的区别 # 在Java中，静态内部类和非静态内部类都是一种嵌套在其他类中的内部类。它们之间有以下几点区别：\n实例化方式：静态内部类可以直接通过外部类名来实例化，而非静态内部类必须要通过外部类的实例来实例化。 对外部类的引用：静态内部类不持有对外部类实例的引用，而非静态内部类则会持有对外部类实例的引用。这意味着在静态内部类中不能直接访问外部类的非静态成员（方法或字段），而非静态内部类可以。 生命周期：静态内部类的生命周期与外部类相互独立，即使外部类实例被销毁，静态内部类仍然存在。非静态内部类的生命周期与外部类实例绑定，只有在外部类实例存在时才能创建非静态内部类的实例。 访问权限：静态内部类对外部类的访问权限与其他类一样，根据访问修饰符而定。非静态内部类可以访问外部类的所有成员，包括私有成员。 ","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741324059033-java-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/","section":"Posts","summary":"","title":"java 抽象类\u0026接口\u0026内部类","type":"posts"},{"content":" 方法 # 1.1方法的定义和调用 # 方法是程序中最小的执行单元。\n方法必须先创建才可以使用，该过程成为方法的定义。 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程称为方法调用。 无参数方法定义和调用：\n定义格式：\npublic static void 方法名 ( ) { // 方法体; } 调用格式：\n方法名(); 注意：\n​\t方法必须先定义，后调用，否则程序将报错\n带参数方法定义和调用：\n定义格式：\n参数：由数据类型和变量名组成： 数据类型 变量名\npublic static void 方法名 (参数1) { 方法体; } public static void 方法名 (参数1, 参数2, 参数3...) { 方法体; } 注意：\n方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错 方法定义时，多个参数之间使用逗号( ，)分隔 调用格式：\n方法名(参数)； 方法名(参数1,参数2); 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错\n带返回值方法的定义和调用：\n定义格式：\npublic static 数据类型 方法名 ( 参数 ) { return 数据 ; } 注意：\n​\t方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\n调用格式：\n方法名 ( 参数 ) ; 数据类型 变量名 = 方法名 ( 参数 ) ; 方法的返回值通常会使用变量接收，否则该返回值将无意义\n1.2 可变长参数 # 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。\npublic static void method1(String... args) { //...... } 另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。\npublic static void method2(String arg1, String... args) { //...... } 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？\n会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。Java 的可变参数编译后实际会被转换成一个数组。\n1.3 方法的注意事项 # 方法不能嵌套定义 void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据 方法的通用格式：\npublic static 返回值类型 方法名(参数) { 方法体; return 数据 ; } 解释：\npublic static 修饰符，目前先记住这个格式\n返回值类型\t方法操作完毕之后返回的数据的数据类型\n​\t如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\n方法名\t调用方法时候使用的标识\n参数\t由数据类型和变量名组成，多个参数之间用逗号隔开\n方法体\t完成功能的代码块\nreturn\t如果方法操作完毕，有数据返回，用于把数据返回给调用者\n定义方法时，要做到两个明确：\n明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型 明确参数：主要是明确参数的类型和数量 调用方法时的注意：\nvoid类型的方法，直接调用即可 非void类型的方法，推荐用变量接收调用 静态方法1为什么不能调用非静态成员？\n静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\n在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\n关于静态方法更多内容参考：静态方法\n1.4 方法重载 # 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\n多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同 注意：\n重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 静态方法（Static Method）是属于类而不是类的实例的方法。它可以在不创建类的实例的情况下被调用。静态方法通常用于执行与类相关的操作，而不需要访问或修改特定实例的状态。在Java中，声明静态方法需要使用static关键字。静态方法可以直接属于类，而不是类的实例。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323931762-java-%E6%96%B9%E6%B3%95/","section":"Posts","summary":"","title":"java 方法","type":"posts"},{"content":" Java概述 # 1.1 Java是什么？ # 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。\n==Java是一门非常火的计算机语言。==\n1.2 JDK的安装目录介绍 # 目录名称 说明 bin 该目录下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该目录下存放了JDK的相关配置文件。 include 该目录下存放了一些平台特定的头文件。 jmods 该目录下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充jar包。 1.3 BUG # 在电脑系统或程序中，隐藏着的未被发现的缺陷或问题统称为bug(漏洞)。\n1.4 Java的三大平台 # 1.4.1 JavaSE # Java 平台标准版，Java 编程语言的基础，它包含了==支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件==。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。\n1.4.2 JavaME # java语言的小型版，==用于嵌入式消费类电子设备或者小型移动设备的开发。==\n其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给代替了，不过安卓也是用Java来开发的。\n1.4.3 JavaEE # Java 平台企业版，建立在 Java SE 的基础上，==包含了支持企业级应用程序开发和部署的标准和规范==（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。\n1.5 Java的主要特性 # 面向对象（封装，继承，多态） 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源） 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持） 简单易用（语法简单，上手容易） 开源 跨平台（ Java 虚拟机实现平台无关性） 修正：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread\n1.6 Java语言跨平台的原理 # 操作系统本身是不认识java语言的。 针对于不同的操作系统，java提供了不同的虚拟机（JVM）。 虚拟机会把java语言翻译成操作系统可以看的懂的语言。\n1.7 JVM \u0026amp; JRE \u0026amp; JDK # ==JVM，java虚拟机。==\n==JRE，java运行环境，包含了JVM和java的核心类库（Java API）==\n==JDK,称为java开发工具，包含了jre和开发工具。==\n当我们在安装时，只需要安装JDK即可，它包含了java的运行环境和虚拟机。\n1.7.1 JVM # Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。==JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果==。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。\n如下图所示，不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure \u0026hellip;）通过各自的编译器编译成 .class 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。\nJVM并不止有一种，只要满足JVM规范，每个公司、组织或者个人都可以开发自己的专属JVM，我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已，我们可以在Java SE Specifications 上找到各个版本的 JDK 对应的 JVM 规范。\n下面这张图是 JVM 的大致结构模型。\n1.7.2 JDK和JRE # ==JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序==。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。\n==JRE是运行已编译 Java 程序所需的环境==，主要包含以下两个部分：\nJVM : 也就是我们上面提到的 Java 虚拟机。 Java 基础类库（Class Library）：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。 简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。\n如果需要编写、编译 Java 程序或使用 Java API 文档，就需要安装 JDK。某些需要 Java 特性的应用程序（如 JSP 转换为 Servlet 或使用反射）也可能需要 JDK 来编译和运行 Java 代码。因此，即使不进行 Java 开发工作，有时也可能需要安装 JDK。\n下图清晰展示了 JDK、JRE 和 JVM 的关系。\n从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ jlink 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。\n1.8 Java语言的运行 # Java 程序从源代码到运行的过程如下图所示：\n我们需要格外注意的是 .class-\u0026gt;机器码 这一步。**在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。**而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。**当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。**而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。\n扩展：有关JIT实现的细节：JVM C1、C2编译器\nHotSpot1 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。\nJDK、JRE、JVM、JIT\n这四者的关系如下图所示。\n为什么说 Java 语言“编译与解释并存”？\n因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。\n我们可以将高级编程语言2按照程序的执行方式分为两种：\n编译型：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。\n解释型：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。\n为了改善解释语言的效率而发展出的即时编译技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码。到执行期时，再将字节码直译，之后执行。Java与LLVM是这种技术的代表产物。\n相关阅读：基本功 | Java 即时编译器原理解析及实践\n1.8.1 JIT与AOT # JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。**AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。**并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。\nJIT 与 AOT 两者的关键指标对比:\n可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。\n既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？\nAOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，==AOT 编译无法支持 Java 的一些动态特性==，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。\n1.9 Java和C++的区别 # Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。 C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。 …… HotSpot是较新的Java虚拟机，用来代替JIT(Just in Time)，可以大大提高Java运行的性能。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n高级编程语言：是一种独立于机器，面向过程或对象的语言。 高级语言是参照数学语言而设计的近似于日常会话的语言。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323804725-java-%E6%A6%82%E8%BF%B0/","section":"Posts","summary":"","title":"java 概述","type":"posts"},{"content":" 流程控制语句 # 流程控制语句分类：\n​\t顺序结构\n​\t判断和选择结构(if, switch)\n​\t循环结构(for, while, do…while)\n1.1 顺序结构 # 顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\n1.2 判断语句：if语句 # 1.2.1 if语句格式 1 # 格式： if (关系表达式) { 语句体;\t} 执行流程：\n①首先计算关系表达式的值\n②如果关系表达式的值为true就执行语句体\n③如果关系表达式的值为false就不执行语句体\n④继续执行后面的语句内容\n如果我们要对一个布尔类型的变量进行判断，不要写 == ，直接把变量写在小括号中即可。\n如果大括号中的语句体只有一条，那么大括号可以省略不写\n如果大括号省略了，那么if只能控制距离他最近的那一条语句。\n**建议：**自己不要去写，如果别人这么写了，你要能看懂即可。\n1.2.2 if语句格式 2 # 格式： if (关系表达式) { 语句体1;\t} else { 语句体2;\t} 执行流程：\n①首先计算关系表达式的值\n②如果关系表达式的值为true就执行语句体1\n③如果关系表达式的值为false就执行语句体2\n④继续执行后面的语句内容\n1.2.3 if语句格式 3 # 格式： if (关系表达式1) { 语句体1;\t} else if (关系表达式2) { 语句体2;\t} … else { 语句体n+1; } 执行流程：\n①首先计算关系表达式1的值\n②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\n③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\n④…\n⑤如果没有任何关系表达式为true，就执行语句体n+1。\n1.2.4 switch语句 # switch (表达式) { case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break; } 执行流程：\n首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 switch的扩展知识：\ndefault的位置和省略情况\ndefault可以放在任意位置，也可以省略\ncase穿透\n不写break会引发case穿透现象\nswitch在JDK12的新特性\nint number = 10; switch (number) { case 1 -\u0026gt; System.out.println(\u0026#34;一\u0026#34;); case 2 -\u0026gt; System.out.println(\u0026#34;二\u0026#34;); case 3 -\u0026gt; System.out.println(\u0026#34;三\u0026#34;); default -\u0026gt; System.out.println(\u0026#34;其他\u0026#34;); } switch和if第三种格式各自的使用场景 1.3 循环结构 # 1.3.1 for循环结构 # 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。\nfor循环格式：\nfor (初始化语句;条件判断语句;条件控制语句) { 循环体语句; } 格式解释：\n初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程：\n①执行初始化语句\n②执行条件判断语句，看其结果是true还是false\n​ 如果是false，循环结束\n​ 如果是true，继续执行\n③执行循环体语句\n④执行条件控制语句\n⑤回到②继续\n1.3.2 while循环 # 循环格式：\n初始化语句; while(条件判断语句){ 循环体; 条件控制语句; } 1.3.3 do····while循环 # 格式：\n初始化语句; do{ 循环体; 条件控制语句; }while(条件判断语句); 特点：\n​\t先执行，再判断。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323871069-java-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","section":"Posts","summary":"","title":"java 流程控制语句","type":"posts"},{"content":" 运算符 # 1.1 运算符与表达式 # 运算符\n​\t就是对常量或者变量进行操作的符号。\n​\t比如： + - * /\n表达式\n​\t用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。\n​\t比如：a + b 这个整体就是表达式。\n​\t而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。\n1.2 算术运算符 # 分类：\n+ - * / % 运算特点：\n+ - * :跟小学数学中一模一样没有任何区别. /： 1.整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。 2.小数直接参与运算，得到的结果有可能是不精确的。 案例： System.out.println( 10 / 3);//3 System.out.println(10.0 / 3);//3.3333333333333335 %：取模、取余。 他做的也是除法运算，只不过获取的是余数而已。 案例： System.out.println(10 % 2);//0 System.out.println(10 % 3);//1 应用场景： //可以利用取模来判断一个数是奇数还是偶数 System.out.println(15 % 2);//1 奇数 1.3 隐式转换 # 也叫自动类型提升。\n​\t==就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。==\n两种提升规则：\n取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。 byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。 取值范围从小到大的关系：\n​\tbyte \u0026lt; short \u0026lt; int \u0026lt; long \u0026lt; float \u0026lt; double\n1.4 强制转换 # 如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。\n​\t如果一定要这么干，就需要加入强制转换。\n书写格式：\n​\t目标数据类型 变量名 = （目标数据类型）被强转的数据；\n简单理解：\n​\t要转成什么类型的，那么就在小括号中写什么类型就可以了。\n注意点：\n​\t强制转换有可能会导致数据发生错误。（数据的精度丢失）\n1.5 字符串的 + 操作 # 当 + 操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。 当连续进行 + 操作时，从左到右逐个执行的。 1.6 字符的 + 操作 # 当+操作中出现了字符，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。\nASCII码表中：\n​\t\u0026lsquo;a\u0026rsquo; \u0026mdash;\u0026ndash; 97\n​\t\u0026lsquo;A\u0026rsquo; \u0026mdash;\u0026ndash; 65\n1.7 自增自减运算符 # ++ 自增运算符 -- 自减运算符 ++：就是把变量里面的值 +1\n\u0026ndash;：就是把变量里面的值 -1\n使用方式：\n放在变量的前面，我们叫做先++。 比如：++a 放在变量的后面，我们叫做后++。 比如：a++ 注意点：\n​\t不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。\n先++ 与 后++ 的区别：\n无论前++，后++，最后都会自增1，区别在于是先自增，还是先参与运算。(自减与自增类似)。\n​ 前++：先进行+1操作。\n​ 后++：后进行+1操作。\n1.8 赋值运算符 # 最为常用的：\t=\n运算过程：就是把等号右边的结果赋值给左边的变量\n1.9 扩展赋值运算符 # 分类：\n​\t+=、-=、*=、/=、%=\n运算规则：\n​\t就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。\n注意点：\n​ 扩展的赋值运算符中隐层还包含了一个强制转换。\n以+=为例。\na += b ;实际上相当于 a = (byte)(a + b);\n1.10 关系运算符 # 又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。\n符号 解释 == 就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false != 就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false \u0026gt; 就是判断左边是否大于右边，如果成立就是true，如果不成立就是false \u0026gt;= 就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false \u0026lt; 就是判断左边是否小于右边，如果成立就是true，如果不成立就是false \u0026lt;= 就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false 注意点：\n关系运算符最终的结果一定是布尔类型的。要么是true，要么是false 在写 == 的时候，千万不要写成 = 1.11 逻辑运算符 # \u0026amp; 和 | 的使用：\n\u0026amp;：逻辑与（而且）\n​\t两边都为真，结果才是真，只要有一个为假，那么结果就是假。\n|：逻辑或（或者）\n​\t两边都为假，结果才是假，只要有一个为真，那么结果就是真。\n^（异或）的使用：\n​\t在以后用的不多，了解一下即可。\n计算规则：如果两边相同，结果为false，如果两边不同，结果为true\n!（取反）的使用：\n​\t是取反，也叫做非。\n计算规则：false取反就是true，true取反就是false\n温馨提示：取反最多只用一个。\n1.12 短路逻辑运算符 # \u0026amp;\u0026amp;：\n​\t运算结果跟\u0026amp;是一模一样的，只不过具有短路效果。\n||：\n​\t运算结果跟|是一模一样的。只不过具有短路效果。\n逻辑核心：\n​\t当左边不能确定整个表达式的结果，右边才会执行。\n​\t当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。\n1.13 三元运算符 # 又叫做：三元表达式或者问号冒号表达式。\n格式：\n​\t关系表达式 ？ 表达式1 ：表达式2 ；\n计算规则：\n计算关系表达式的值。 如果关系表达式的值为真，那么执行表达式1。 如果关系表达式的值为假，那么执行表达式2。 注意点：\n​\t三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。\n1.14 运算符的优先级 # 在Java中涉及了很多的运算符，每一种运算符都有各自的优先级。但是这些优先级不需要记忆。\n咱们只要知道其中一点：\n​\t小括号优先于所有。\n1.15 移位运算符 # 移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。\n移位运算符在各种框架以及 JDK 自身的源码中使用还是挺广泛的，HashMap（JDK1.8） 中的 hash 方法的源码就用到了移位运算符：\nstatic final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // \u0026gt;\u0026gt;\u0026gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 使用移位运算符的主要原因：\n高效：移位运算符直接对应于处理器的移位指令。现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。\n节省内存：通过移位操作，可以使用一个整数（如 int 或 long）来存储多个布尔值或标志位，从而节省内存。\n移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：\n位字段管理：例如存储和操作多个布尔值。 哈希算法和加密解密：通过移位和与、或等操作来混淆数据。 数据压缩：例如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，以生成紧凑的压缩格式。 数据校验：例如 CRC（循环冗余校验）通过移位和多项式除法生成和校验数据完整性。。 内存对齐：通过移位操作，可以轻松计算和调整数据的对齐地址。 Java 中有三种移位运算符：\n\u0026lt;\u0026lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x \u0026lt;\u0026lt; n,相当于 x 乘以 2 的 n 次方(不溢出的情况下)。 \u0026gt;\u0026gt; :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x \u0026gt;\u0026gt; n,相当于 x 除以 2 的 n 次方。 \u0026gt;\u0026gt;\u0026gt; :无符号右移，忽略符号位，空位都以 0 补齐。 虽然移位运算本质上可以分为左移和右移，但在实际应用中，右移操作需要考虑符号位的处理方式。\n由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。\n移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。\n如果移位的位数超过数值所占有的位数会怎样？\n当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。\n也就是说：x\u0026lt;\u0026lt;42等同于x\u0026lt;\u0026lt;10，x\u0026gt;\u0026gt;42等同于x\u0026gt;\u0026gt;10，x \u0026gt;\u0026gt;\u0026gt;42等同于x \u0026gt;\u0026gt;\u0026gt; 10。\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323849157-java-%E8%BF%90%E7%AE%97%E7%AC%A6/","section":"Posts","summary":"","title":"java 运算符","type":"posts"},{"content":" 面向对象 # 1.1 类和对象 # 客观存在的事务皆为对象，所以我们也常常说万物皆对象。\n类：\n==类是对现实生活中一类具有共同属性和行为的事物的抽象== 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成：\n属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系：\n类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.1.1 类的定义 # 类的组成是由属性和行为两部分组成\n属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤：\n①定义类\n②编写类的成员变量\n③编写类的成员方法\npublic class 类名 { // 成员变量 变量1的数据类型 变量1； 变量2的数据类型 变量2; … // 成员方法 方法1; 方法2;\t} 1.1.2 对象的使用 # 创建对象的格式：\n​\t类名 对象名 = new 类名();\nnew 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。\n一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）； 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 对象的相等和引用相等的区别\n对象的相等一般比较的是内存中存放的内容是否相等。 引用相等一般比较的是他们指向的内存地址是否相等。 调用成员的格式：\n​\t对象名.成员变量\n​\t对象名.成员方法();\n1.1.3 面向对象和面向过程的区别 # 面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：\n面向过程编程（POP）：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象编程（OOP）：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 相比较于 POP，OOP 开发的程序一般具有下面这些优点：\n易维护：由于良好的结构和封装性，OOP 程序通常更容易维护。 易复用：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。 易扩展：模块化设计使得系统扩展变得更加容易和灵活。 POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。\nPOP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。\n1.1.4 创建对象的几种额外方式 # 在Java中，有以下几种常见的方式来创建对象：\n使用new关键字：这是最常见的创建对象的方式。通过调用类的构造函数，使用new关键字可以在内存中分配一个新的对象。\n使用反射：Java的反射机制允许在运行时动态地创建对象。通过获取类的Class对象，并调用其构造函数，可以实现对象的创建。\n使用newInstance()方法：某些类提供了newInstance()方法来创建对象，这种方式只适用于具有默认无参构造函数的类。\n使用clone()方法：如果类实现了Cloneable接口，就可以使用clone()方法创建对象的副本。\n使用对象的反序列化：通过将对象序列化到一个字节流中，然后再进行反序列化，可以创建对象的副本。\n其中，使用new关键字是最常见和推荐的创建对象的方式。其他方式通常在特定场景下使用，如需要动态创建对象或创建对象的副本等情况。\n1.2 对象内存图 # 1.2.1 单个对象内存图 # 成员变量使用过程 成员方法调用过程 1.2.2 多个对象内存图 # 成员变量使用过程 成员方法调用过程 总结\n多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\n1.3 成员变量和局部变量 # 成员变量和局部变量的区别：\n语法形式不同：从语法形式上看，==成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数==；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 存储方式不同：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而==对象存在于堆内存，局部变量则存在于栈内存==。\n生存时间不同：从变量在内存中的生存时间上看，==成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡==。\n默认值不同：从变量是否有默认值来看，==成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值==（一种情况例外:被 final 修饰的成员变量也必须显式地赋值）。而==局部变量则不会自动赋值，必须先定义，赋值才能使用==\n为什么成员变量有默认值？\n先不考虑变量类型，如果没有默认值，变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。 默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。 对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。 1.4 封装 # 1.4.1 封装思想 # 封装概述 是面向对象三大特征之一（封装，继承，多态）\n==封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。==\n如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\n封装代码实现 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法\n1.4.2 private关键字 # private是一个修饰符，可以用来修饰成员（成员变量，成员方法）\n被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 1.4.3 this关键字 # this修饰的变量用于指代成员变量，其主要作用是区分局部变量和成员变量的重名问题 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 我们以实体类中的set方法为例，因为set方法的形参和成员变量同名，所以带this的是成员变量，idea自动生成的set方法如下：\npublic void setA(int a) { this.a = a; } 除此之外，在全参构造时，情况也与此类似\n1.5 构造方法 # 1.5.1 构造方法概述 # 构造方法是一种特殊的方法\n作用：创建对象 Student stu = new Student();\n格式：\npublic class 类名{\n​ 修饰符 类名( 参数 ) {\n​ }\n}\n功能：主要是完成对象数据的初始化\n1.5.2 构造方法的注意事项 # 构造方法的创建 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 如果定义了构造方法，系统将不再提供默认的构造方法\n构造方法的重载 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法\n推荐的使用方式 无论是否使用，都手工书写无参数构造方法\n重要功能 可以使用带参构造，为成员变量进行初始化\n如果一个类没有声明构造方法，该程序能正确执行吗？\n构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。\n如果一个类没有声明构造方法，也可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。\n我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到）。\n构造方法有哪些特点？是否可被override?\n构造方法具有以下特点：\n名称与类名相同：构造方法的名称必须与类名完全一致。 没有返回值：构造方法没有返回类型，且不能使用 void 声明。 自动执行：在生成类的对象时，构造方法会自动执行，无需显式调用。 构造方法不能被重写（override），但可以被重载（overload）。因此，一个类中可以有多个构造方法，这些构造方法可以具有不同的参数列表，以提供不同的对象初始化方式。\n1.5.3 标准类制作 # ① 类名需要见名知意\n② 成员变量使用private修饰\n③ 提供至少两个构造方法\n无参构造方法 带全部参数的构造方法 ④ get和set方法\n​\t提供每一个成员变量对应的setXxx()/getXxx()\n⑤ 如果还有其他行为，也需要写上\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/1741323945921-java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","section":"Posts","summary":"","title":"java 面向对象","type":"posts"},{"content":" IO流简介 # IO 即 Input/Output，输入和输出。**数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。**IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。\nJava IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\nInputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 IO基础总结 # 1.1 字节流 # 一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，**字节流可以传输任意文件数据。**在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n1.1.1 InputStream（字节输入流） # InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。\nInputStream 常用方法：\npublic abstract int read()：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。 public int read(byte[] b)： 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。 read(byte b[], int off, int len)：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 skip(long n)：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。 available()：返回输入流中可以读取的字节数。 public void close() ：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：\nreadAllBytes()：读取输入流中的所有字节，返回字节数组。 readNBytes(byte[] b, int off, int len)：阻塞直到读取 len 个字节。 transferTo(OutputStream out)：将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。\n构造方法\nFileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。\n读取字节数据\n读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1。\n虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 。\n使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\nFileInputStream 代码示例：\ntry (InputStream fis = new FileInputStream(\u0026#34;input.txt\u0026#34;)) { System.out.println(\u0026#34;Number of remaining bytes:\u0026#34; + fis.available()); int content; long skip = fis.skip(2); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } input.txt 文件内容：\n输出：\nNumber of remaining bytes:11 The actual number of bytes skipped:2 The content read from file:JavaGuide 不过，一般我们是不会直接单独使用 FileInputStream ，通常会配合 BufferedInputStream（字节缓冲输入流，后文会讲到）来使用。\n像下面这段代码在我们的项目中就比较常见，我们通过 readAllBytes() 读取输入流所有字节并将其直接赋值给一个 String 对象。\n// 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;)); // 读取文件的内容并复制到 String 对象中 String result = new String(bufferedInputStream.readAllBytes()); System.out.println(result); DataInputStream 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 FileInputStream 。\nFileInputStream fileInputStream = new FileInputStream(\u0026#34;input.txt\u0026#34;); //必须将fileInputStream作为构造参数才能使用 DataInputStream dataInputStream = new DataInputStream(fileInputStream); //可以读取任意具体的类型数据 dataInputStream.readBoolean(); dataInputStream.readInt(); dataInputStream.readUTF(); ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。\nObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;object.data\u0026#34;)); MyClass object = (MyClass) input.readObject(); input.close(); 另外，用于序列化和反序列化的类必须实现 Serializable 接口，对象中如果有属性不想被序列化，使用 transient 修饰。\n1.1.2 OutputStream(字节输出流) # OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。\nOutputStream 常用方法：\npublic void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流，等价于 write(b, 0, b.length) 。 public void write(byte[] b, int off, int len) ：在write(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 public abstract void write(int b) ：将指定的字节输出流。 小贴士：\nclose方法，当完成流的操作时，必须调用此方法，释放系统资源。\nFileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。\n构造方法\npublic FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n写出字节数据\n写出字节：write(int b) 方法，每次可以写出一个字节数据。\n虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据。\n写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节。\n数据追加续写\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\npublic FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了。\n写出换行\nWindows系统里，换行符号是\\r\\n 。\n回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 FileOutputStream 代码示例：\ntry (FileOutputStream output = new FileOutputStream(\u0026#34;output.txt\u0026#34;)) { byte[] array = \u0026#34;JavaGuide\u0026#34;.getBytes(); output.write(array); } catch (IOException e) { e.printStackTrace(); } 运行结果：\n类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，后文会讲到）来使用。\nFileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream) DataOutputStream 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 FileOutputStream 。\n// 输出流 FileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;out.txt\u0026#34;); DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream); // 输出任意数据类型 dataOutputStream.writeBoolean(true); dataOutputStream.writeByte(1); ObjectInputStream 用于从输入流中读取 Java 对象（ObjectInputStream,反序列化），ObjectOutputStream将对象写入到输出流(ObjectOutputStream，序列化)。\nObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\u0026#34;file.txt\u0026#34;) Person person = new Person(\u0026#34;Guide哥\u0026#34;, \u0026#34;JavaGuide作者\u0026#34;); output.writeObject(person); 1.2 字符流 # 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I/O 流操作要分为字节流操作和字符流操作呢？\n个人认为主要有两点原因：\n字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。 如果我们不知道编码类型就很容易出现乱码问题。 比如遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n乱码问题这个很容易就可以复现，我们只需要将上面提到的 FileInputStream 代码示例中的 input.txt 文件内容改为中文即可，原代码不需要改动。\n输出：\nNumber of remaining bytes:9 The actual number of bytes skipped:2 The content read from file:§å®¶å¥½ 可以很明显地看到读取出来的内容已经变成了乱码。\n因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。\n字符流默认采用的是 Unicode 编码，我们可以通过构造方法自定义编码。\nUnicode 本身只是一种字符集，它为每个字符分配一个唯一的数字编号，并没有规定具体的存储方式。UTF-8、UTF-16、UTF-32 都是 Unicode 的编码方式，它们使用不同的字节数来表示 Unicode 字符。例如，UTF-8 :英文占 1 字节，中文占 3 字节。\n1.2.1 Reader(字符输入流) # Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。\nReader 用于读取文本， InputStream 用于读取原始字节。\nReader 常用方法：\npublic int read() : 从输入流读取一个字符。 public int read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。 read(char[] cbuf, int off, int len)：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 skip(long n)：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。 public void close() : 关闭输入流并释放相关的系统资源。 InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。\n// 字节流转换为字符流的桥梁 public class InputStreamReader extends Reader { } // 用于读取字符文件 public class FileReader extends InputStreamReader { } java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n小贴士：\n字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\nidea中UTF-8\n字节缓冲区：一个字节数组，用来临时存储字节数据。\n构造方法\nFileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n读取字符数据\n读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取。\n虽然读取了一个字符，但是会自动提升为int类型。\n使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 。\nFileReader 代码示例：\ntry (FileReader fileReader = new FileReader(\u0026#34;input.txt\u0026#34;);) { int content; long skip = fileReader.skip(3); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fileReader.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } input.txt 文件内容：\n输出：\nThe actual number of bytes skipped:3 The content read from file:我是Guide。 1.2.2 Writer(字符输出流) # Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。\nWriter 常用方法：\nvoid write(int c) : 写入单个字符。 void write(char[] cbuf) ：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。 abstract void write(char[] cbuf, int off, int len) ：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 void write(String str)：写入字符串，等价于 write(str, 0, str.length()) 。 void write(String str, int off, int len)：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 append(CharSequence csq)：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。 append(char c)：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。 void flush()：刷新此输出流并强制写出所有缓冲的输出字符。 void close():关闭输出流释放相关的系统资源。 OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。\n// 字符流转换为字节流的桥梁 public class OutputStreamWriter extends Writer { } // 用于写入字符到文件 public class FileWriter extends OutputStreamWriter { } 构造方法\nFileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n基本写出数据\n写出字符：write(int b) 方法，每次可以写出一个字符数据。\n虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。\nflush ：刷新缓冲区，流对象可以继续使用。 close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n写出其他数据\n写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream。\n写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便。\n续写和换行：操作类似于FileOutputStream。\n字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流\nFileWriter 代码示例：\ntry (Writer output = new FileWriter(\u0026#34;output.txt\u0026#34;)) { output.write(\u0026#34;你好，我是Guide。\u0026#34;); } catch (IOException e) { e.printStackTrace(); } 输出结果：\n1.3 字节缓冲流 # IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。\n字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\n// 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;)); 字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。\n我使用 write(int b) 和 read() 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：\n使用缓冲流复制PDF文件总耗时:15428 毫秒 使用普通字节流复制PDF文件总耗时:2555062 毫秒 两者耗时差别非常大，缓冲流耗费的时间是字节流的 1/165。\n测试代码如下:\n@Test void copy_pdf_to_another_pdf_buffer_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;))) { int content; while ((content = bis.read()) != -1) { bos.write(content); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用缓冲流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } @Test void copy_pdf_to_another_pdf_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (FileInputStream fis = new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;)) { int content; while ((content = fis.read()) != -1) { fos.write(content); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用普通流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } 如果是调用 read(byte b[]) 和 write(byte b[], int off, int len) 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。\n这次我们使用 read(byte b[]) 和 write(byte b[], int off, int len) 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：\n使用缓冲流复制PDF文件总耗时:695 毫秒 使用普通字节流复制PDF文件总耗时:989 毫秒 两者耗时差别不是很大，缓冲流的性能要略微好一点点。\n测试代码如下：\n@Test void copy_pdf_to_another_pdf_with_byte_array_buffer_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;))) { int len; byte[] bytes = new byte[4 * 1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用缓冲流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } @Test void copy_pdf_to_another_pdf_with_byte_array_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (FileInputStream fis = new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;)) { int len; byte[] bytes = new byte[4 * 1024]; while ((len = fis.read(bytes)) != -1) { fos.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用普通流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } 1.3.1 BufferedInputStream(字节缓冲输入流) # BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。\nBufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 BufferedInputStream 源码即可得到这个结论。\npublic class BufferedInputStream extends FilterInputStream { // 内部缓冲区数组 protected volatile byte buf[]; // 缓冲区的默认大小 private static int DEFAULT_BUFFER_SIZE = 8192; // 使用默认的缓冲区大小 public BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } // 自定义缓冲区大小 public BufferedInputStream(InputStream in, int size) { super(in); if (size \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;Buffer size \u0026lt;= 0\u0026#34;); } buf = new byte[size]; } } 缓冲区的大小默认为 8192 字节，当然了，你也可以通过 BufferedInputStream(InputStream in, int size) 这个构造方法来指定缓冲区的大小。\n1.3.2 BufferedOutputStream(字节缓冲输出流) # BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率\ntry (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;))) { byte[] array = \u0026#34;JavaGuide\u0026#34;.getBytes(); bos.write(array); } catch (IOException e) { e.printStackTrace(); } 类似于 BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 8192 字节。\n1.4 字符缓冲流 # BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。\n1.5 打印流 # 下面这段代码大家经常使用吧？\nSystem.out.print(\u0026#34;Hello！\u0026#34;); System.out.println(\u0026#34;Hello！\u0026#34;); System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。\nPrintStream 属于字节打印流，与之对应的是 PrintWriter （字符打印流）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。\npublic class PrintStream extends FilterOutputStream implements Appendable, Closeable { } public class PrintWriter extends Writer { } 1.6 随机访问流 # 这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 RandomAccessFile 。\nRandomAccessFile 的构造方法如下，我们可以指定 mode（读写模式）。\n// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除 public RandomAccessFile(File file, String mode) throws FileNotFoundException { this(file, mode, false); } // 私有方法 private RandomAccessFile(File file, String mode, boolean openAndDelete) throws FileNotFoundException{ // 省略大部分代码 } 读写模式主要有下面四种：\nr : 只读模式。 rw: 读写模式 rws: 相对于 rw，rws 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。 rwd : 相对于 rw，rwd 同步更新对“文件的内容”的修改到外部存储设备。 文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。\nRandomAccessFile 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 RandomAccessFile 的 seek(long pos) 方法来设置文件指针的偏移量（距文件开头 pos 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 getFilePointer() 方法。\nRandomAccessFile 代码示例：\nRandomAccessFile randomAccessFile = new RandomAccessFile(new File(\u0026#34;input.txt\u0026#34;), \u0026#34;rw\u0026#34;); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); // 指针当前偏移量为 6 randomAccessFile.seek(6); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); // 从偏移量 7 的位置开始往后写入字节数据 randomAccessFile.write(new byte[]{\u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;}); // 指针当前偏移量为 0，回到起始位置 randomAccessFile.seek(0); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); input.txt 文件内容：\n输出：\n读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1 读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7 读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1 input.txt 文件内容变为 ABCDEFGHIJK 。\nRandomAccessFile 的 write 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。\nRandomAccessFile randomAccessFile = new RandomAccessFile(new File(\u0026#34;input.txt\u0026#34;), \u0026#34;rw\u0026#34;); randomAccessFile.write(new byte[]{\u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;}); 假设运行上面这段程序之前 input.txt 文件内容变为 ABCD ，运行之后则变为 HIJK 。\nRandomAccessFile 比较常见的一个应用就是实现大文件的 断点续传 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。\nRandomAccessFile 可以帮助我们合并文件分片，示例代码如下：\n大文件的上传问题：\nIO设计模式总结 # 2.1 装饰器模式 # 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。\n装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。\n对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。\n我们常见的BufferedInputStream(字节缓冲输入流)、DataInputStream 等等都是FilterInputStream 的子类，BufferedOutputStream（字节缓冲输出流）、DataOutputStream等等都是FilterOutputStream的子类。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\nBufferedInputStream 构造函数如下：\npublic BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } public BufferedInputStream(InputStream in, int size) { super(in); if (size \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;Buffer size \u0026lt;= 0\u0026#34;); } buf = new byte[size]; } 可以看出，BufferedInputStream 的构造函数其中的一个参数就是 InputStream 。\nBufferedInputStream 代码示例：\ntry (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;))) { int content; long skip = bis.skip(2); while ((content = bis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } 这个时候，你可以会想了：为啥我们直接不弄一个BufferedFileInputStream（字符缓冲文件输入流）呢？\nBufferedFileInputStream bfis = new BufferedFileInputStream(\u0026#34;input.txt\u0026#34;); 如果 InputStream的子类比较少的话，这样做是没问题的。不过， InputStream的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。\n如果你对 IO 流比较熟悉的话，你会发现ZipInputStream 和ZipOutputStream 还可以分别增强 BufferedInputStream 和 BufferedOutputStream 的能力。\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName)); ZipInputStream zis = new ZipInputStream(bis); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileName)); ZipOutputStream zipOut = new ZipOutputStream(bos); ZipInputStream 和ZipOutputStream 分别继承自InflaterInputStream 和DeflaterOutputStream。\npublic class InflaterInputStream extends FilterInputStream { } public class DeflaterOutputStream extends FilterOutputStream { } 这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。\n为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 InputStream 和OutputStream。\n对于字符流来说，BufferedReader 可以用来增加 Reader （字符输入流）子类的功能，BufferedWriter 可以用来增加 Writer （字符输出流）子类的功能。\nBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), \u0026#34;UTF-8\u0026#34;)); IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。\n2.2 适配器模式 # 适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。\n适配器模式中存在被适配的对象或者类称为 适配者(Adaptee) ，作用于适配者的对象或者类称为适配器(Adapter) 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\nIO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。\nInputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder （流解码器）对字节进行解码，实现字节流到字符流的转换， OutputStreamWriter 使用StreamEncoder（流编码器）对字符进行编码，实现字符流到字节流的转换。\nInputStream 和 OutputStream 的子类是被适配者， InputStreamReader 和 OutputStreamWriter是适配器。\n// InputStreamReader 是适配器，FileInputStream 是被适配的类 InputStreamReader isr = new InputStreamReader(new FileInputStream(fileName), \u0026#34;UTF-8\u0026#34;); // BufferedReader 增强 InputStreamReader 的功能（装饰器模式） BufferedReader bufferedReader = new BufferedReader(isr); java.io.InputStreamReader 部分源码：\npublic class InputStreamReader extends Reader { //用于解码的对象 private final StreamDecoder sd; public InputStreamReader(InputStream in) { super(in); try { // 获取 StreamDecoder 对象 sd = StreamDecoder.forInputStreamReader(in, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } // 使用 StreamDecoder 对象做具体的读取工作 public int read() throws IOException { return sd.read(); } } java.io.OutputStreamWriter 部分源码：\npublic class OutputStreamWriter extends Writer { // 用于编码的对象 private final StreamEncoder se; public OutputStreamWriter(OutputStream out) { super(out); try { // 获取 StreamEncoder 对象 se = StreamEncoder.forOutputStreamWriter(out, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } // 使用 StreamEncoder 对象做具体的写入工作 public void write(int c) throws IOException { se.write(c); } } 适配器模式和装饰器模式有什么区别呢？\n装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 StreamDecoder （流解码器）和StreamEncoder（流编码器）就是分别基于 InputStream 和 OutputStream 来获取 FileChannel对象并调用对应的 read 方法和 write 方法进行字节数据的读取和写入。\nStreamDecoder(InputStream in, Object lock, CharsetDecoder dec) { // 省略大部分代码 // 根据 InputStream 对象获取 FileChannel 对象 ch = getChannel((FileInputStream)in); } 适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n另外，FutureTask 类使用了适配器模式，Executors 的内部类 RunnableAdapter 实现属于适配器，用于将 Runnable 适配成 Callable。\nFutureTask参数包含 Runnable 的一个构造方法：\npublic FutureTask(Runnable runnable, V result) { // 调用 Executors 类的 callable 方法 this.callable = Executors.callable(runnable, result); this.state = NEW; } Executors中对应的方法和适配器：\n// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法 public static \u0026lt;T\u0026gt; Callable\u0026lt;T\u0026gt; callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter\u0026lt;T\u0026gt;(task, result); } // 适配器 static final class RunnableAdapter\u0026lt;T\u0026gt; implements Callable\u0026lt;T\u0026gt; { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } 2.3 工厂模式 # 工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 Files 类的 newInputStream 方法用于创建 InputStream 对象（静态工厂）、 Paths 类的 get 方法创建 Path 对象（静态工厂）、ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（简单工厂）。\nInputStream is = Files.newInputStream(Paths.get(generatorLogoPath)) 2.4 观察者模式 # NIO 中的文件目录监听服务使用到了观察者模式。\nNIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。\nWatchable接口定义了一个用于将对象注册到WatchService（监控服务） 并绑定监听事件的方法 register。\npublic interface Path extends Comparable\u0026lt;Path\u0026gt;, Iterable\u0026lt;Path\u0026gt;, Watchable{ } public interface Watchable { WatchKey register(WatchService watcher, WatchEvent.Kind\u0026lt;?\u0026gt;[] events, WatchEvent.Modifier... modifiers) throws IOException; } WatchService 用于监听文件目录的变化，同一个 WatchService 对象能够监听多个文件目录。\n// 创建 WatchService 对象 WatchService watchService = FileSystems.getDefault().newWatchService(); // 初始化一个被监控文件夹的 Path 类: Path path = Paths.get(\u0026#34;workingDirectory\u0026#34;); // 将这个 path 对象注册到 WatchService（监控服务） 中去 WatchKey watchKey = path.register( watchService, StandardWatchEventKinds...); Path 类 register 方法的第二个参数 events （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。\nWatchKey register(WatchService watcher, WatchEvent.Kind\u0026lt;?\u0026gt;... events) throws IOException; 常用的监听事件有 3 种：\nStandardWatchEventKinds.ENTRY_CREATE：文件创建。 StandardWatchEventKinds.ENTRY_DELETE : 文件删除。 StandardWatchEventKinds.ENTRY_MODIFY : 文件修改。 register 方法返回 WatchKey 对象，通过WatchKey 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。\nWatchKey key; while ((key = watchService.take()) != null) { for (WatchEvent\u0026lt;?\u0026gt; event : key.pollEvents()) { // 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息 } key.reset(); } WatchService 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。\nclass PollingWatchService extends AbstractWatchService { // 定义一个 daemon thread（守护线程）轮询检测文件变化 private final ScheduledExecutorService scheduledExecutor; PollingWatchService() { scheduledExecutor = Executors .newSingleThreadScheduledExecutor(new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); t.setDaemon(true); return t; }}); } void enable(Set\u0026lt;? extends WatchEvent.Kind\u0026lt;?\u0026gt;\u0026gt; events, long period) { synchronized (this) { // 更新监听事件 this.events = events; // 开启定期轮询 Runnable thunk = new Runnable() { public void run() { poll(); }}; this.poller = scheduledExecutor .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS); } } } IO模型详解 # 3.1 I/O # 3.1.1 何为I/O? # I/O（Input/Output） 即输入／输出 。\n我们先从计算机结构的角度来解读一下 I/O。\n根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。\n输入设备向计算机输入数据，输出设备接收计算机输出的数据。\n从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。\n我们再先从应用程序的角度来解读一下 I/O。\n根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。\n像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。\n并且，用户空间的程序不能直接访问内核空间。\n当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。\n因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间\n我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。\n从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。\n当应用程序发起 I/O 调用后，会经历两个步骤：\n内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间。 3.1.2 有哪些常见的 IO 模型? # UNIX 系统下， IO 模型一共有 5 种：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。\n这也是我们经常提到的 5 种 IO 模型。\n3.2 Java中常见的3中IO模型 # 3.2.1 BIO（Blocking I/O） # BIO 属于同步阻塞 IO 模型 。\n同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n3.2.2 NIO (Non-blocking/New I/O) # Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\nJava 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n跟着我的思路往下看看，相信你会得到答案！\n我们先来看看 同步非阻塞 IO 模型。\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n这个时候，I/O 多路复用模型 就上场了。\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -\u0026gt; 用户空间)还是阻塞的。\n目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。\nselect 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 epoll 调用：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。 面试必备：对 select，poll，epoll 的详细解析_poll和select和epoll的作用-CSDN博客\nIO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。\nJava 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\n3.2.3.1 Buffer # 一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。\njava.nio 定义了以下几个 Buffer 的实现:\n其实核心是最后的 ByteBuffer，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。\n我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。\nMappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。\n我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。\nposition、limit、capacity\n就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。\nJava NIO:Buffer、Channel 和 Selector详解（通俗易懂）_java 流读取数据和channel读取数据底层流程-CSDN博客\n3.2.3 AIO（Asynchronous I/O） # AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。\n最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。\n3.2.4 BIO、NIO、AIO有什么区别 # 他们三者都是Java中常用的I/O模型，我们从以下三个维度进行对比：\n1.阻塞与非阻塞：\nBIO是阻塞式I/O模型，线程会一直被阻塞等待操作完成。 NIO是非阻塞式I/O模型，线程可以去做其他任务，当I/O操作完成时得到通知。 AIO也是非阻塞式I/O模型，不需要用户线程关注I/O事件，由操作系统通过回调机制处理。 2.缓冲区：\nBIO使用传统的字节流和字符流，需要为输入输出流分别创建缓冲区。 NIO引入了基于通道和缓冲区的I/O方式，使用一个缓冲区完成数据读写操作。 AIO则不需要缓冲区，使用异步回调方式进行操作。 3.线程模型：\nBIO采用一个线程处理一个请求方式，面对高并发时线程数量急剧增加，容易导致系统崩溃。 NIO采用多路复用器来监听多个客户端请求，使用一个线程处理，减少线程数量，提高系统性能。 AIO依靠操作系统完成I/O操作，不需要额外的线程池或多路复用器。 综上所述，BIO、NIO、AIO的区别主要在于阻塞与非阻塞、缓冲区和线程模型等方面。根据具体应用场景选择合适的I/O模型可以提高程序的性能和可扩展性。\nIO异常 # 4.1 IO异常的处理 # JDK7前处理：\n建议使用try...catch...finally 代码块，处理异常部分\nJDK7的处理：\ntry-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n格式：\ntry (创建流对象语句，如果多个,使用\u0026#39;;\u0026#39;隔开) { // 读写数据 } catch (IOException e) { e.printStackTrace(); } JDK9的改进：\nJDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close。\n改进前格式：\n// 被final修饰的对象 final Resource resource1 = new Resource(\u0026#34;resource1\u0026#34;); // 普通对象 Resource resource2 = new Resource(\u0026#34;resource2\u0026#34;); // 引入方式：创建新的变量保存 try (Resource r1 = resource1; Resource r2 = resource2) { // 使用对象 } 改进后格式：\n// 被final修饰的对象 final Resource resource1 = new Resource(\u0026#34;resource1\u0026#34;); // 普通对象 Resource resource2 = new Resource(\u0026#34;resource2\u0026#34;); // 引入方式：直接引入 try (resource1; resource2) { // 使用对象 } 其他流 # 5.1 缓冲流 # 缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：\n字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n5.1.1 字节缓冲流 # 构造方法：\npublic BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 5.1.2 字符缓冲流 # 构造方法：\npublic BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 特有方法：\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\nBufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 5.2 转换流 # 字符编码\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n编码:字符(能看懂的)\u0026ndash;字节(看不懂的)\n解码:字节(看不懂的)\u0026ndash;\u0026gt;字符(能看懂的)\n字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n编码表:生活中文字和计算机中二进制的对应规则\n5.2.1字符集 # 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。\n可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。\nASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\u0026quot;全角\u0026quot;字符，而原来在127号以下的那些就叫\u0026quot;半角\u0026quot;字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码引出的问题：\n在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n5.2.2 InputStreamReader类 # 转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n构造方法：\nInputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 指定编码读取：\n// 定义文件路径,文件为gbk编码 String FileName = \u0026#34;E:\\\\file_gbk.txt\u0026#34;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \u0026#34;GBK\u0026#34;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) { System.out.print((char)read); // ��Һ� } isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) { System.out.print((char)read);// 大家好 } isr2.close(); } 5.2.3 OutputStreamWriter类 # 转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n构造方法\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 转换流理解图解\n5.3 打印流 # 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n5.3.1 PrintStream类 # 构造方法\npublic PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。\n改变打印流向\nSystem.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\u0026quot;小把戏\u0026quot;，改变它的流向。\npublic class PrintDemo { public static void main(String[] args) throws IOException { // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\u0026#34;ps.txt\u0026#34;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); } } 5.4 压缩流和解压缩流 # 压缩流：\n​\t负责压缩文件或者文件夹\n解压缩流：\n​\t负责把压缩包中的文件和文件夹解压出来\n//1.创建一个File表示要解压的压缩包 File src = new File(\u0026#34;D:\\\\aaa.zip\u0026#34;); //2.创建一个File表示解压的目的地 File dest = new File(\u0026#34;D:\\\\\u0026#34;); //调用方法 unzip(src,dest); //压缩流 toZip(src,dest); ","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741259090641-io/","section":"Posts","summary":"","title":"IO","type":"posts"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":" Java值传递详解 # 1.1 形参 \u0026amp; 实参 # 方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：\n实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。 String hello = \u0026#34;Hello!\u0026#34;; // hello 为实参 sayHello(hello); // str 为形参 void sayHello(String str) { System.out.println(str); } 1.2 值传递 \u0026amp; 引用传递 # 程序设计语言将实参传递给方法（或函数）的方式分为两种：\n值传递：方法接收的是实参值的拷贝，会创建副本。 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。 很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。\n1.3 为什么Java只有值传递 # 为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。\n1.3.1 案例1：传递基本参数类型 # 代码：\npublic static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\u0026#34;num1 = \u0026#34; + num1); System.out.println(\u0026#34;num2 = \u0026#34; + num2); } public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\u0026#34;a = \u0026#34; + a); System.out.println(\u0026#34;b = \u0026#34; + b); } 输出：\na = 20 b = 10 num1 = 10 num2 = 20 解析：\n在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。\n1.3.2 案例2：传递引用类型参数1 # 代码：\npublic static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } 输出：\n1 0 解析：\n看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。\n实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！\n也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。\n为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！\n1.3.3 案例3：传递引用类型参数2 # public class Person { private String name; // 省略构造函数、Getter\u0026amp;Setter方法 } public static void main(String[] args) { Person xiaoZhang = new Person(\u0026#34;小张\u0026#34;); Person xiaoLi = new Person(\u0026#34;小李\u0026#34;); swap(xiaoZhang, xiaoLi); System.out.println(\u0026#34;xiaoZhang:\u0026#34; + xiaoZhang.getName()); System.out.println(\u0026#34;xiaoLi:\u0026#34; + xiaoLi.getName()); } public static void swap(Person person1, Person person2) { Person temp = person1; person1 = person2; person2 = temp; System.out.println(\u0026#34;person1:\u0026#34; + person1.getName()); System.out.println(\u0026#34;person2:\u0026#34; + person2.getName()); } 输出:\nperson1:小李 person2:小张 xiaoZhang:小张 xiaoLi:小李 解析：\n怎么回事？？？两个引用类型的形参互换并没有影响实参啊！\n注：引用传递在对引用类型参数进行传递时同样是传递地址，两个引用类型的形参呼唤同样不会影响实参。\nswap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。\n1.4 引用传递是怎么样的 # 看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目。\n#include \u0026lt;iostream\u0026gt; void incr(int\u0026amp; num) { std::cout \u0026lt;\u0026lt; \u0026#34;incr before: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; num++; std::cout \u0026lt;\u0026lt; \u0026#34;incr after: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { int age = 10; std::cout \u0026lt;\u0026lt; \u0026#34;invoke before: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; incr(age); std::cout \u0026lt;\u0026lt; \u0026#34;invoke after: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 输出结果：\ninvoke before: 10 incr before: 10 incr after: 11 invoke after: 11 分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int\u0026amp; 才为引用传递，如果是用 int 的话还是值传递哦！\n1.5 为什么Java不引入引用传递 # 引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？\n注意：以下为个人观点看法，并非来自于 Java 官方：\n出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。 Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。 1.6 总结 # Java 中将实参传递给方法（或函数）的方式是 值传递：\n如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。 ","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741275961641-java-%E5%80%BC%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/","section":"Posts","summary":"","title":"java 值传递详解","type":"posts"},{"content":" Java序列化详解 # 1.1 序列化和反序列化 # 在计算机网络中，==序列化（Serialization）和反序列化（Deserialization）是指将数据结构或对象转换成可传输或存储的格式，以及从该格式还原成原始数据结构或对象的过程。==序列化是为了在网络中传输数据或将数据存储到磁盘等介质时，能够方便地将数据转换成字节流。反序列化则是将接收到的字节流还原成原始的数据结构或对象。\nJava的序列化过程就是指将Java对象转换为字节流的过程，可以将这些字节流保存到文件中或通过网络传输。 序列化的主要目的是 实现对象的持久化存储和传输，让对象可以在不同的计算机或不同的时间点被重建和使用。通过序列化，可以将对象的状态以字节的形式保存下来，并且在需要的时候进行恢复，从而实现了对象的跨平台传输和持久化存储。\n简单来说：\n序列化：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式 反序列化：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程 对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。\n序列化和反序列化常见应用场景：\n对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 维基百科是如是介绍序列化的：\n序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。\n综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。\nhttps://www.corejavaguru.com/java/serialization/interview-questions-1\n序列化协议对应于 TCP/IP 4 层模型的哪一层？\n我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？\n应用层 传输层 网络层 网络接口层 如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？\n因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。\n1.2 初始协议 # **在网络通信中，通信双方需要遵循一定的协议来确保正确、有效地进行数据交换。协议定义了通信的规则、格式以及消息的含义。**协议可以包括序列化和反序列化的规范，以确保数据在传输过程中能够正确地被解析。\n例如，常见的网络协议如HTTP、TCP、UDP等都规定了数据传输的格式和交互方式。对于数据的序列化和反序列化，有时候也需要使用特定的协议，例如JSON、XML、Protocol Buffers等。\n**初识协议是指对于通信过程中双方之间要遵循的规定、约定或规则。**这些规定定义了通信的格式、数据交换方式、消息的含义等，确保通信的双方能够理解和正确地处理彼此发送和接收的信息。协议在计算机网络、分布式系统、通信领域等都起到了关键的作用。\n协议可以分为多种类型，其中两个主要的类别是通信协议和传输协议。\n通信协议：\n**通信协议定义了通信双方之间的交流规则，包括消息的格式、语法、语义和同步方式。**一些常见的通信协议包括：\nHTTP（Hypertext Transfer Protocol）： 用于在Web浏览器和Web服务器之间传递信息，基于请求-响应模型。\nFTP（File Transfer Protocol）： 用于在客户端和服务器之间传输文件。\nSMTP（Simple Mail Transfer Protocol）： 用于在邮件客户端和邮件服务器之间传输电子邮件。\nDNS（Domain Name System）： 用于将域名映射到IP地址。\n传输协议：\n**传输协议定义了数据在网络中的传输方式，**包括数据的分段、重组、错误处理等。两个常见的传输协议是：\nTCP（Transmission Control Protocol）： 提供可靠的、面向连接的通信。TCP保证数据的可靠性，确保数据按照正确的顺序到达目的地。\nUDP（User Datagram Protocol）： 提供不可靠的、无连接的通信。UDP不保证数据的可靠性，但通常速度更快。\n序列化协议:\n在分布式系统中，**序列化协议定义了数据在网络上传输时的格式，以及如何将数据结构转换为字节流，以便在网络上传输。**一些常见的序列化协议包括：\nJSON（JavaScript Object Notation）： 一种轻量级的数据交换格式，易于阅读和编写，但性能较差。\nXML（eXtensible Markup Language）： 一种可扩展的标记语言，常用于表示结构化数据，易于阅读和编写，但性能较差。\nProtocol Buffers（protobuf）： 由Google开发的二进制序列化协议，具有高效的编码和解码速度。\n了解和遵循协议对于确保系统之间的正确通信和数据交换至关重要。协议的设计考虑到了性能、可扩展性、可读性等方面的因素，因此在设计和开发过程中需要谨慎选择和遵循适当的协议。\nJDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。\n1.2.1 JDK自带的序列化方式 # JDK 自带的序列化，只需实现 java.io.Serializable(/ˈsɪərɪəlaɪzəbl/)接口即可。\n@AllArgsConstructor @NoArgsConstructor @Getter @Builder @ToString public class RpcRequest implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private String requestId; private String interfaceName; private String methodName; private Object[] parameters; private Class\u0026lt;?\u0026gt;[] paramTypes; private RpcMessageTypeEnum rpcMessageTypeEnum; } 所有的非静态、非瞬态的字段都可以被序列化。 使用Java的序列化机制，可以通过ObjectOutputStream将对象转换为字节流并写入文件或网络流中。反之，通过ObjectInputStream可以从字节流中读取数据并还原为对象。\nserialVersionUID 有什么用？\n序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。\nserialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？\nstatic 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。\n🐛 修正（参见：issue#2174）：static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，serialVersionUID 是一个特例，serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出 InvalidClassException，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。\n官方说明如下：\nA serializable class can declare its own serialVersionUID explicitly by declaring a field named \u0026quot;serialVersionUID\u0026quot; that must be static, final, and of type long;\n如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 \u0026quot;serialVersionUID\u0026quot; 。\n也就是说，serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。\n如果有些字段不想进行序列化怎么办？\n对于不想进行序列化的变量，可以使用 transient (/ˈtrænziənt/)关键字修饰。\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。\n关于 transient 还有几点注意：\ntransient 只能修饰变量，不能修饰类和方法。 transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。 static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。 为什么不推荐使用 JDK 自带的序列化？\n我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：\n不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：应用安全:JAVA 反序列化漏洞之殇 - Cryin、Java 反序列化安全漏洞怎么回事? - Monica。 1.2.1.1 ObjectOutputStream类 # java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n构造方法：\npublic ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。\n序列化操作：\n一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1.2.1.2 ObjectInputStream类 # ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n构造方法\npublic ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。\n反序列化操作1\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\npublic final Object readObject () : 读取一个对象。 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n反序列化操作2\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。**发生这个异常的原因如下：\n该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n1.2.2 Kryo # Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。\n另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。\nguide-rpc-framework 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：\n/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */ @Slf4j public class KryoSerializer implements Serializer { /** * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects */ private final ThreadLocal\u0026lt;Kryo\u0026gt; kryoThreadLocal = ThreadLocal.withInitial(() -\u0026gt; { Kryo kryo = new Kryo(); kryo.register(RpcResponse.class); kryo.register(RpcRequest.class); return kryo; }); @Override public byte[] serialize(Object obj) { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream)) { Kryo kryo = kryoThreadLocal.get(); // Object-\u0026gt;byte:将对象序列化为byte数组 kryo.writeObject(output, obj); kryoThreadLocal.remove(); return output.toBytes(); } catch (Exception e) { throw new SerializeException(\u0026#34;Serialization failed\u0026#34;); } } @Override public \u0026lt;T\u0026gt; T deserialize(byte[] bytes, Class\u0026lt;T\u0026gt; clazz) { try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); Input input = new Input(byteArrayInputStream)) { Kryo kryo = kryoThreadLocal.get(); // byte-\u0026gt;Object:从byte数组中反序列化出对象 Object o = kryo.readObject(input, clazz); kryoThreadLocal.remove(); return clazz.cast(o); } catch (Exception e) { throw new SerializeException(\u0026#34;Deserialization failed\u0026#34;); } } } GitHub 地址：https://github.com/EsotericSoftware/kryo 。\n1.2.3 Protobuf # Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。\nProtobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言\n一个简单的 proto 文件如下：\n// protobuf的版本 syntax = \u0026#34;proto3\u0026#34;; // SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct message Person { //string类型字段 string name = 1; // int 类型字段 int32 age = 2; } GitHub 地址：https://github.com/protocolbuffers/protobuf。\n1.2.4 ProtoStuff # 由于 Protobuf 的易用性较差，它的哥哥 Protostuff 诞生了。\nprotostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。\nGitHub 地址：https://github.com/protostuff/protostuff。\n1.2.5 Hessian # Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。\nDubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。\n1.2.6 总结 # Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/serialization/）。\n像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。\n除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。\n","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741276121143-java-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/","section":"Posts","summary":"","title":"java 序列化详解","type":"posts"},{"content":"an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\n","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741229251595-new-article/","section":"Posts","summary":"","title":"new-article","type":"posts"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","section":"Tags","summary":"","title":"基础总结","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]