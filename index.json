
[{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/","section":"Blog homepage","summary":"","title":"Blog homepage","type":"page"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" IO流简介 # IO 即 Input/Output，输入和输出。**数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。**IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。\nJava IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\nInputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 IO基础总结 # 1.1 字节流 # 一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，**字节流可以传输任意文件数据。**在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n1.1.1 InputStream（字节输入流） # InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。\nInputStream 常用方法：\npublic abstract int read()：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。 public int read(byte[] b)： 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。 read(byte b[], int off, int len)：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 skip(long n)：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。 available()：返回输入流中可以读取的字节数。 public void close() ：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：\nreadAllBytes()：读取输入流中的所有字节，返回字节数组。 readNBytes(byte[] b, int off, int len)：阻塞直到读取 len 个字节。 transferTo(OutputStream out)：将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。\n构造方法\nFileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。\n读取字节数据\n读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1。\n虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 。\n使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\nFileInputStream 代码示例：\ntry (InputStream fis = new FileInputStream(\u0026#34;input.txt\u0026#34;)) { System.out.println(\u0026#34;Number of remaining bytes:\u0026#34; + fis.available()); int content; long skip = fis.skip(2); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } input.txt 文件内容：\n输出：\nNumber of remaining bytes:11 The actual number of bytes skipped:2 The content read from file:JavaGuide 不过，一般我们是不会直接单独使用 FileInputStream ，通常会配合 BufferedInputStream（字节缓冲输入流，后文会讲到）来使用。\n像下面这段代码在我们的项目中就比较常见，我们通过 readAllBytes() 读取输入流所有字节并将其直接赋值给一个 String 对象。\n// 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;)); // 读取文件的内容并复制到 String 对象中 String result = new String(bufferedInputStream.readAllBytes()); System.out.println(result); DataInputStream 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 FileInputStream 。\nFileInputStream fileInputStream = new FileInputStream(\u0026#34;input.txt\u0026#34;); //必须将fileInputStream作为构造参数才能使用 DataInputStream dataInputStream = new DataInputStream(fileInputStream); //可以读取任意具体的类型数据 dataInputStream.readBoolean(); dataInputStream.readInt(); dataInputStream.readUTF(); ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流(序列化)。\nObjectInputStream input = new ObjectInputStream(new FileInputStream(\u0026#34;object.data\u0026#34;)); MyClass object = (MyClass) input.readObject(); input.close(); 另外，用于序列化和反序列化的类必须实现 Serializable 接口，对象中如果有属性不想被序列化，使用 transient 修饰。\n1.1.2 OutputStream(字节输出流) # OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。\nOutputStream 常用方法：\npublic void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流，等价于 write(b, 0, b.length) 。 public void write(byte[] b, int off, int len) ：在write(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 public abstract void write(int b) ：将指定的字节输出流。 小贴士：\nclose方法，当完成流的操作时，必须调用此方法，释放系统资源。\nFileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。\n构造方法\npublic FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n写出字节数据\n写出字节：write(int b) 方法，每次可以写出一个字节数据。\n虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据。\n写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节。\n数据追加续写\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\npublic FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了。\n写出换行\nWindows系统里，换行符号是\\r\\n 。\n回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 FileOutputStream 代码示例：\ntry (FileOutputStream output = new FileOutputStream(\u0026#34;output.txt\u0026#34;)) { byte[] array = \u0026#34;JavaGuide\u0026#34;.getBytes(); output.write(array); } catch (IOException e) { e.printStackTrace(); } 运行结果：\n类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，后文会讲到）来使用。\nFileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;output.txt\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream) DataOutputStream 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 FileOutputStream 。\n// 输出流 FileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;out.txt\u0026#34;); DataOutputStream dataOutputStream = new DataOutputStream(fileOutputStream); // 输出任意数据类型 dataOutputStream.writeBoolean(true); dataOutputStream.writeByte(1); ObjectInputStream 用于从输入流中读取 Java 对象（ObjectInputStream,反序列化），ObjectOutputStream将对象写入到输出流(ObjectOutputStream，序列化)。\nObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\u0026#34;file.txt\u0026#34;) Person person = new Person(\u0026#34;Guide哥\u0026#34;, \u0026#34;JavaGuide作者\u0026#34;); output.writeObject(person); 1.2 字符流 # 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I/O 流操作要分为字节流操作和字符流操作呢？\n个人认为主要有两点原因：\n字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。 如果我们不知道编码类型就很容易出现乱码问题。 比如遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n乱码问题这个很容易就可以复现，我们只需要将上面提到的 FileInputStream 代码示例中的 input.txt 文件内容改为中文即可，原代码不需要改动。\n输出：\nNumber of remaining bytes:9 The actual number of bytes skipped:2 The content read from file:§å®¶å¥½ 可以很明显地看到读取出来的内容已经变成了乱码。\n因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。\n字符流默认采用的是 Unicode 编码，我们可以通过构造方法自定义编码。\nUnicode 本身只是一种字符集，它为每个字符分配一个唯一的数字编号，并没有规定具体的存储方式。UTF-8、UTF-16、UTF-32 都是 Unicode 的编码方式，它们使用不同的字节数来表示 Unicode 字符。例如，UTF-8 :英文占 1 字节，中文占 3 字节。\n1.2.1 Reader(字符输入流) # Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。\nReader 用于读取文本， InputStream 用于读取原始字节。\nReader 常用方法：\npublic int read() : 从输入流读取一个字符。 public int read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。 read(char[] cbuf, int off, int len)：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 skip(long n)：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。 public void close() : 关闭输入流并释放相关的系统资源。 InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。\n// 字节流转换为字符流的桥梁 public class InputStreamReader extends Reader { } // 用于读取字符文件 public class FileReader extends InputStreamReader { } java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n小贴士：\n字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\nidea中UTF-8\n字节缓冲区：一个字节数组，用来临时存储字节数据。\n构造方法\nFileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n读取字符数据\n读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取。\n虽然读取了一个字符，但是会自动提升为int类型。\n使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 。\nFileReader 代码示例：\ntry (FileReader fileReader = new FileReader(\u0026#34;input.txt\u0026#34;);) { int content; long skip = fileReader.skip(3); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fileReader.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } input.txt 文件内容：\n输出：\nThe actual number of bytes skipped:3 The content read from file:我是Guide。 1.2.2 Writer(字符输出流) # Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。\nWriter 常用方法：\nvoid write(int c) : 写入单个字符。 void write(char[] cbuf) ：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。 abstract void write(char[] cbuf, int off, int len) ：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 void write(String str)：写入字符串，等价于 write(str, 0, str.length()) 。 void write(String str, int off, int len)：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 append(CharSequence csq)：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。 append(char c)：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。 void flush()：刷新此输出流并强制写出所有缓冲的输出字符。 void close():关闭输出流释放相关的系统资源。 OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。\n// 字符流转换为字节流的桥梁 public class OutputStreamWriter extends Writer { } // 用于写入字符到文件 public class FileWriter extends OutputStreamWriter { } 构造方法\nFileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n基本写出数据\n写出字符：write(int b) 方法，每次可以写出一个字符数据。\n虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。\nflush ：刷新缓冲区，流对象可以继续使用。 close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n写出其他数据\n写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream。\n写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便。\n续写和换行：操作类似于FileOutputStream。\n字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流\nFileWriter 代码示例：\ntry (Writer output = new FileWriter(\u0026#34;output.txt\u0026#34;)) { output.write(\u0026#34;你好，我是Guide。\u0026#34;); } catch (IOException e) { e.printStackTrace(); } 输出结果：\n1.3 字节缓冲流 # IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。\n字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\n// 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;)); 字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 write(int b) 和 read() 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。\n我使用 write(int b) 和 read() 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：\n使用缓冲流复制PDF文件总耗时:15428 毫秒 使用普通字节流复制PDF文件总耗时:2555062 毫秒 两者耗时差别非常大，缓冲流耗费的时间是字节流的 1/165。\n测试代码如下:\n@Test void copy_pdf_to_another_pdf_buffer_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;))) { int content; while ((content = bis.read()) != -1) { bos.write(content); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用缓冲流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } @Test void copy_pdf_to_another_pdf_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (FileInputStream fis = new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;)) { int content; while ((content = fis.read()) != -1) { fos.write(content); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用普通流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } 如果是调用 read(byte b[]) 和 write(byte b[], int off, int len) 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。\n这次我们使用 read(byte b[]) 和 write(byte b[], int off, int len) 方法，分别通过字节流和字节缓冲流复制一个 524.9 mb 的 PDF 文件耗时对比如下：\n使用缓冲流复制PDF文件总耗时:695 毫秒 使用普通字节流复制PDF文件总耗时:989 毫秒 两者耗时差别不是很大，缓冲流的性能要略微好一点点。\n测试代码如下：\n@Test void copy_pdf_to_another_pdf_with_byte_array_buffer_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;))) { int len; byte[] bytes = new byte[4 * 1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用缓冲流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } @Test void copy_pdf_to_another_pdf_with_byte_array_stream() { // 记录开始时间 long start = System.currentTimeMillis(); try (FileInputStream fis = new FileInputStream(\u0026#34;深入理解计算机操作系统.pdf\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;深入理解计算机操作系统-副本.pdf\u0026#34;)) { int len; byte[] bytes = new byte[4 * 1024]; while ((len = fis.read(bytes)) != -1) { fos.write(bytes, 0, len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\u0026#34;使用普通流复制PDF文件总耗时:\u0026#34; + (end - start) + \u0026#34; 毫秒\u0026#34;); } 1.3.1 BufferedInputStream(字节缓冲输入流) # BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。\nBufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 BufferedInputStream 源码即可得到这个结论。\npublic class BufferedInputStream extends FilterInputStream { // 内部缓冲区数组 protected volatile byte buf[]; // 缓冲区的默认大小 private static int DEFAULT_BUFFER_SIZE = 8192; // 使用默认的缓冲区大小 public BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } // 自定义缓冲区大小 public BufferedInputStream(InputStream in, int size) { super(in); if (size \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;Buffer size \u0026lt;= 0\u0026#34;); } buf = new byte[size]; } } 缓冲区的大小默认为 8192 字节，当然了，你也可以通过 BufferedInputStream(InputStream in, int size) 这个构造方法来指定缓冲区的大小。\n1.3.2 BufferedOutputStream(字节缓冲输出流) # BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率\ntry (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;))) { byte[] array = \u0026#34;JavaGuide\u0026#34;.getBytes(); bos.write(array); } catch (IOException e) { e.printStackTrace(); } 类似于 BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 8192 字节。\n1.4 字符缓冲流 # BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。\n1.5 打印流 # 下面这段代码大家经常使用吧？\nSystem.out.print(\u0026#34;Hello！\u0026#34;); System.out.println(\u0026#34;Hello！\u0026#34;); System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。\nPrintStream 属于字节打印流，与之对应的是 PrintWriter （字符打印流）。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类。\npublic class PrintStream extends FilterOutputStream implements Appendable, Closeable { } public class PrintWriter extends Writer { } 1.6 随机访问流 # 这里要介绍的随机访问流指的是支持随意跳转到文件的任意位置进行读写的 RandomAccessFile 。\nRandomAccessFile 的构造方法如下，我们可以指定 mode（读写模式）。\n// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除 public RandomAccessFile(File file, String mode) throws FileNotFoundException { this(file, mode, false); } // 私有方法 private RandomAccessFile(File file, String mode, boolean openAndDelete) throws FileNotFoundException{ // 省略大部分代码 } 读写模式主要有下面四种：\nr : 只读模式。 rw: 读写模式 rws: 相对于 rw，rws 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。 rwd : 相对于 rw，rwd 同步更新对“文件的内容”的修改到外部存储设备。 文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。\nRandomAccessFile 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 RandomAccessFile 的 seek(long pos) 方法来设置文件指针的偏移量（距文件开头 pos 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 getFilePointer() 方法。\nRandomAccessFile 代码示例：\nRandomAccessFile randomAccessFile = new RandomAccessFile(new File(\u0026#34;input.txt\u0026#34;), \u0026#34;rw\u0026#34;); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); // 指针当前偏移量为 6 randomAccessFile.seek(6); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); // 从偏移量 7 的位置开始往后写入字节数据 randomAccessFile.write(new byte[]{\u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;}); // 指针当前偏移量为 0，回到起始位置 randomAccessFile.seek(0); System.out.println(\u0026#34;读取之前的偏移量：\u0026#34; + randomAccessFile.getFilePointer() + \u0026#34;,当前读取到的字符\u0026#34; + (char) randomAccessFile.read() + \u0026#34;，读取之后的偏移量：\u0026#34; + randomAccessFile.getFilePointer()); input.txt 文件内容：\n输出：\n读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1 读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7 读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1 input.txt 文件内容变为 ABCDEFGHIJK 。\nRandomAccessFile 的 write 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。\nRandomAccessFile randomAccessFile = new RandomAccessFile(new File(\u0026#34;input.txt\u0026#34;), \u0026#34;rw\u0026#34;); randomAccessFile.write(new byte[]{\u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;}); 假设运行上面这段程序之前 input.txt 文件内容变为 ABCD ，运行之后则变为 HIJK 。\nRandomAccessFile 比较常见的一个应用就是实现大文件的 断点续传 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。\nRandomAccessFile 可以帮助我们合并文件分片，示例代码如下：\n大文件的上传问题：\nIO设计模式总结 # 2.1 装饰器模式 # 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。\n装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。\n对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。\n我们常见的BufferedInputStream(字节缓冲输入流)、DataInputStream 等等都是FilterInputStream 的子类，BufferedOutputStream（字节缓冲输出流）、DataOutputStream等等都是FilterOutputStream的子类。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\nBufferedInputStream 构造函数如下：\npublic BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } public BufferedInputStream(InputStream in, int size) { super(in); if (size \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;Buffer size \u0026lt;= 0\u0026#34;); } buf = new byte[size]; } 可以看出，BufferedInputStream 的构造函数其中的一个参数就是 InputStream 。\nBufferedInputStream 代码示例：\ntry (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;))) { int content; long skip = bis.skip(2); while ((content = bis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } 这个时候，你可以会想了：为啥我们直接不弄一个BufferedFileInputStream（字符缓冲文件输入流）呢？\nBufferedFileInputStream bfis = new BufferedFileInputStream(\u0026#34;input.txt\u0026#34;); 如果 InputStream的子类比较少的话，这样做是没问题的。不过， InputStream的子类实在太多，继承关系也太复杂了。如果我们为每一个子类都定制一个对应的缓冲输入流，那岂不是太麻烦了。\n如果你对 IO 流比较熟悉的话，你会发现ZipInputStream 和ZipOutputStream 还可以分别增强 BufferedInputStream 和 BufferedOutputStream 的能力。\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName)); ZipInputStream zis = new ZipInputStream(bis); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileName)); ZipOutputStream zipOut = new ZipOutputStream(bos); ZipInputStream 和ZipOutputStream 分别继承自InflaterInputStream 和DeflaterOutputStream。\npublic class InflaterInputStream extends FilterInputStream { } public class DeflaterOutputStream extends FilterOutputStream { } 这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。\n为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 InputStream 和OutputStream。\n对于字符流来说，BufferedReader 可以用来增加 Reader （字符输入流）子类的功能，BufferedWriter 可以用来增加 Writer （字符输出流）子类的功能。\nBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), \u0026#34;UTF-8\u0026#34;)); IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。\n2.2 适配器模式 # 适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。\n适配器模式中存在被适配的对象或者类称为 适配者(Adaptee) ，作用于适配者的对象或者类称为适配器(Adapter) 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\nIO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。\nInputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder （流解码器）对字节进行解码，实现字节流到字符流的转换， OutputStreamWriter 使用StreamEncoder（流编码器）对字符进行编码，实现字符流到字节流的转换。\nInputStream 和 OutputStream 的子类是被适配者， InputStreamReader 和 OutputStreamWriter是适配器。\n// InputStreamReader 是适配器，FileInputStream 是被适配的类 InputStreamReader isr = new InputStreamReader(new FileInputStream(fileName), \u0026#34;UTF-8\u0026#34;); // BufferedReader 增强 InputStreamReader 的功能（装饰器模式） BufferedReader bufferedReader = new BufferedReader(isr); java.io.InputStreamReader 部分源码：\npublic class InputStreamReader extends Reader { //用于解码的对象 private final StreamDecoder sd; public InputStreamReader(InputStream in) { super(in); try { // 获取 StreamDecoder 对象 sd = StreamDecoder.forInputStreamReader(in, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } // 使用 StreamDecoder 对象做具体的读取工作 public int read() throws IOException { return sd.read(); } } java.io.OutputStreamWriter 部分源码：\npublic class OutputStreamWriter extends Writer { // 用于编码的对象 private final StreamEncoder se; public OutputStreamWriter(OutputStream out) { super(out); try { // 获取 StreamEncoder 对象 se = StreamEncoder.forOutputStreamWriter(out, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } // 使用 StreamEncoder 对象做具体的写入工作 public void write(int c) throws IOException { se.write(c); } } 适配器模式和装饰器模式有什么区别呢？\n装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 StreamDecoder （流解码器）和StreamEncoder（流编码器）就是分别基于 InputStream 和 OutputStream 来获取 FileChannel对象并调用对应的 read 方法和 write 方法进行字节数据的读取和写入。\nStreamDecoder(InputStream in, Object lock, CharsetDecoder dec) { // 省略大部分代码 // 根据 InputStream 对象获取 FileChannel 对象 ch = getChannel((FileInputStream)in); } 适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n另外，FutureTask 类使用了适配器模式，Executors 的内部类 RunnableAdapter 实现属于适配器，用于将 Runnable 适配成 Callable。\nFutureTask参数包含 Runnable 的一个构造方法：\npublic FutureTask(Runnable runnable, V result) { // 调用 Executors 类的 callable 方法 this.callable = Executors.callable(runnable, result); this.state = NEW; } Executors中对应的方法和适配器：\n// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法 public static \u0026lt;T\u0026gt; Callable\u0026lt;T\u0026gt; callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter\u0026lt;T\u0026gt;(task, result); } // 适配器 static final class RunnableAdapter\u0026lt;T\u0026gt; implements Callable\u0026lt;T\u0026gt; { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } 2.3 工厂模式 # 工厂模式用于创建对象，NIO 中大量用到了工厂模式，比如 Files 类的 newInputStream 方法用于创建 InputStream 对象（静态工厂）、 Paths 类的 get 方法创建 Path 对象（静态工厂）、ZipFileSystem 类（sun.nio包下的类，属于 java.nio 相关的一些内部实现）的 getPath 的方法创建 Path 对象（简单工厂）。\nInputStream is = Files.newInputStream(Paths.get(generatorLogoPath)) 2.4 观察者模式 # NIO 中的文件目录监听服务使用到了观察者模式。\nNIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。\nWatchable接口定义了一个用于将对象注册到WatchService（监控服务） 并绑定监听事件的方法 register。\npublic interface Path extends Comparable\u0026lt;Path\u0026gt;, Iterable\u0026lt;Path\u0026gt;, Watchable{ } public interface Watchable { WatchKey register(WatchService watcher, WatchEvent.Kind\u0026lt;?\u0026gt;[] events, WatchEvent.Modifier... modifiers) throws IOException; } WatchService 用于监听文件目录的变化，同一个 WatchService 对象能够监听多个文件目录。\n// 创建 WatchService 对象 WatchService watchService = FileSystems.getDefault().newWatchService(); // 初始化一个被监控文件夹的 Path 类: Path path = Paths.get(\u0026#34;workingDirectory\u0026#34;); // 将这个 path 对象注册到 WatchService（监控服务） 中去 WatchKey watchKey = path.register( watchService, StandardWatchEventKinds...); Path 类 register 方法的第二个参数 events （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。\nWatchKey register(WatchService watcher, WatchEvent.Kind\u0026lt;?\u0026gt;... events) throws IOException; 常用的监听事件有 3 种：\nStandardWatchEventKinds.ENTRY_CREATE：文件创建。 StandardWatchEventKinds.ENTRY_DELETE : 文件删除。 StandardWatchEventKinds.ENTRY_MODIFY : 文件修改。 register 方法返回 WatchKey 对象，通过WatchKey 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。\nWatchKey key; while ((key = watchService.take()) != null) { for (WatchEvent\u0026lt;?\u0026gt; event : key.pollEvents()) { // 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息 } key.reset(); } WatchService 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化，简化后的源码如下所示。\nclass PollingWatchService extends AbstractWatchService { // 定义一个 daemon thread（守护线程）轮询检测文件变化 private final ScheduledExecutorService scheduledExecutor; PollingWatchService() { scheduledExecutor = Executors .newSingleThreadScheduledExecutor(new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); t.setDaemon(true); return t; }}); } void enable(Set\u0026lt;? extends WatchEvent.Kind\u0026lt;?\u0026gt;\u0026gt; events, long period) { synchronized (this) { // 更新监听事件 this.events = events; // 开启定期轮询 Runnable thunk = new Runnable() { public void run() { poll(); }}; this.poller = scheduledExecutor .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS); } } } IO模型详解 # 3.1 I/O # 3.1.1 何为I/O? # I/O（Input/Output） 即输入／输出 。\n我们先从计算机结构的角度来解读一下 I/O。\n根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。\n输入设备向计算机输入数据，输出设备接收计算机输出的数据。\n从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。\n我们再先从应用程序的角度来解读一下 I/O。\n根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。\n像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。\n并且，用户空间的程序不能直接访问内核空间。\n当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。\n因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间\n我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。\n从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。\n当应用程序发起 I/O 调用后，会经历两个步骤：\n内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间。 3.1.2 有哪些常见的 IO 模型? # UNIX 系统下， IO 模型一共有 5 种：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。\n这也是我们经常提到的 5 种 IO 模型。\n3.2 Java中常见的3中IO模型 # 3.2.1 BIO（Blocking I/O） # BIO 属于同步阻塞 IO 模型 。\n同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n3.2.2 NIO (Non-blocking/New I/O) # Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\nJava 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n跟着我的思路往下看看，相信你会得到答案！\n我们先来看看 同步非阻塞 IO 模型。\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n这个时候，I/O 多路复用模型 就上场了。\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -\u0026gt; 用户空间)还是阻塞的。\n目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。\nselect 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 epoll 调用：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。 面试必备：对 select，poll，epoll 的详细解析_poll和select和epoll的作用-CSDN博客\nIO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。\nJava 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。\n3.2.3.1 Buffer # 一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。\njava.nio 定义了以下几个 Buffer 的实现:\n其实核心是最后的 ByteBuffer，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。\n我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。\nMappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。\n我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。\nposition、limit、capacity\n就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。\nJava NIO:Buffer、Channel 和 Selector详解（通俗易懂）_java 流读取数据和channel读取数据底层流程-CSDN博客\n3.2.3 AIO（Asynchronous I/O） # AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。\n最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。\n3.2.4 BIO、NIO、AIO有什么区别 # 他们三者都是Java中常用的I/O模型，我们从以下三个维度进行对比：\n1.阻塞与非阻塞：\nBIO是阻塞式I/O模型，线程会一直被阻塞等待操作完成。 NIO是非阻塞式I/O模型，线程可以去做其他任务，当I/O操作完成时得到通知。 AIO也是非阻塞式I/O模型，不需要用户线程关注I/O事件，由操作系统通过回调机制处理。 2.缓冲区：\nBIO使用传统的字节流和字符流，需要为输入输出流分别创建缓冲区。 NIO引入了基于通道和缓冲区的I/O方式，使用一个缓冲区完成数据读写操作。 AIO则不需要缓冲区，使用异步回调方式进行操作。 3.线程模型：\nBIO采用一个线程处理一个请求方式，面对高并发时线程数量急剧增加，容易导致系统崩溃。 NIO采用多路复用器来监听多个客户端请求，使用一个线程处理，减少线程数量，提高系统性能。 AIO依靠操作系统完成I/O操作，不需要额外的线程池或多路复用器。 综上所述，BIO、NIO、AIO的区别主要在于阻塞与非阻塞、缓冲区和线程模型等方面。根据具体应用场景选择合适的I/O模型可以提高程序的性能和可扩展性。\nIO异常 # 4.1 IO异常的处理 # JDK7前处理：\n建议使用try...catch...finally 代码块，处理异常部分\nJDK7的处理：\ntry-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n格式：\ntry (创建流对象语句，如果多个,使用\u0026#39;;\u0026#39;隔开) { // 读写数据 } catch (IOException e) { e.printStackTrace(); } JDK9的改进：\nJDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close。\n改进前格式：\n// 被final修饰的对象 final Resource resource1 = new Resource(\u0026#34;resource1\u0026#34;); // 普通对象 Resource resource2 = new Resource(\u0026#34;resource2\u0026#34;); // 引入方式：创建新的变量保存 try (Resource r1 = resource1; Resource r2 = resource2) { // 使用对象 } 改进后格式：\n// 被final修饰的对象 final Resource resource1 = new Resource(\u0026#34;resource1\u0026#34;); // 普通对象 Resource resource2 = new Resource(\u0026#34;resource2\u0026#34;); // 引入方式：直接引入 try (resource1; resource2) { // 使用对象 } 其他流 # 5.1 缓冲流 # 缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：\n字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n5.1.1 字节缓冲流 # 构造方法：\npublic BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 5.1.2 字符缓冲流 # 构造方法：\npublic BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 特有方法：\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\nBufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 5.2 转换流 # 字符编码\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n编码:字符(能看懂的)\u0026ndash;字节(看不懂的)\n解码:字节(看不懂的)\u0026ndash;\u0026gt;字符(能看懂的)\n字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n编码表:生活中文字和计算机中二进制的对应规则\n5.2.1字符集 # 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。\n可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。\nASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\u0026quot;全角\u0026quot;字符，而原来在127号以下的那些就叫\u0026quot;半角\u0026quot;字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码引出的问题：\n在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n5.2.2 InputStreamReader类 # 转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n构造方法：\nInputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 指定编码读取：\n// 定义文件路径,文件为gbk编码 String FileName = \u0026#34;E:\\\\file_gbk.txt\u0026#34;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \u0026#34;GBK\u0026#34;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) { System.out.print((char)read); // ��Һ� } isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) { System.out.print((char)read);// 大家好 } isr2.close(); } 5.2.3 OutputStreamWriter类 # 转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n构造方法\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 转换流理解图解\n5.3 打印流 # 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n5.3.1 PrintStream类 # 构造方法\npublic PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。\n改变打印流向\nSystem.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\u0026quot;小把戏\u0026quot;，改变它的流向。\npublic class PrintDemo { public static void main(String[] args) throws IOException { // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\u0026#34;ps.txt\u0026#34;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); } } 5.4 压缩流和解压缩流 # 压缩流：\n​\t负责压缩文件或者文件夹\n解压缩流：\n​\t负责把压缩包中的文件和文件夹解压出来\n//1.创建一个File表示要解压的压缩包 File src = new File(\u0026#34;D:\\\\aaa.zip\u0026#34;); //2.创建一个File表示解压的目的地 File dest = new File(\u0026#34;D:\\\\\u0026#34;); //调用方法 unzip(src,dest); //压缩流 toZip(src,dest); ","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741259090641-io/","section":"Posts","summary":"","title":"IO","type":"posts"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":" Java值传递详解 # 1.1 形参 \u0026amp; 实参 # 方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：\n实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。 String hello = \u0026#34;Hello!\u0026#34;; // hello 为实参 sayHello(hello); // str 为形参 void sayHello(String str) { System.out.println(str); } 1.2 值传递 \u0026amp; 引用传递 # 程序设计语言将实参传递给方法（或函数）的方式分为两种：\n值传递：方法接收的是实参值的拷贝，会创建副本。 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。 很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。\n1.3 为什么Java只有值传递 # 为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。\n1.3.1 案例1：传递基本参数类型 # 代码：\npublic static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\u0026#34;num1 = \u0026#34; + num1); System.out.println(\u0026#34;num2 = \u0026#34; + num2); } public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\u0026#34;a = \u0026#34; + a); System.out.println(\u0026#34;b = \u0026#34; + b); } 输出：\na = 20 b = 10 num1 = 10 num2 = 20 解析：\n在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。\n1.3.2 案例2：传递引用类型参数1 # 代码：\npublic static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } 输出：\n1 0 解析：\n看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。\n实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！\n也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。\n为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！\n1.3.3 案例3：传递引用类型参数2 # public class Person { private String name; // 省略构造函数、Getter\u0026amp;Setter方法 } public static void main(String[] args) { Person xiaoZhang = new Person(\u0026#34;小张\u0026#34;); Person xiaoLi = new Person(\u0026#34;小李\u0026#34;); swap(xiaoZhang, xiaoLi); System.out.println(\u0026#34;xiaoZhang:\u0026#34; + xiaoZhang.getName()); System.out.println(\u0026#34;xiaoLi:\u0026#34; + xiaoLi.getName()); } public static void swap(Person person1, Person person2) { Person temp = person1; person1 = person2; person2 = temp; System.out.println(\u0026#34;person1:\u0026#34; + person1.getName()); System.out.println(\u0026#34;person2:\u0026#34; + person2.getName()); } 输出:\nperson1:小李 person2:小张 xiaoZhang:小张 xiaoLi:小李 解析：\n怎么回事？？？两个引用类型的形参互换并没有影响实参啊！\n注：引用传递在对引用类型参数进行传递时同样是传递地址，两个引用类型的形参呼唤同样不会影响实参。\nswap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。\n1.4 引用传递是怎么样的 # 看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目。\n#include \u0026lt;iostream\u0026gt; void incr(int\u0026amp; num) { std::cout \u0026lt;\u0026lt; \u0026#34;incr before: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; num++; std::cout \u0026lt;\u0026lt; \u0026#34;incr after: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { int age = 10; std::cout \u0026lt;\u0026lt; \u0026#34;invoke before: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; incr(age); std::cout \u0026lt;\u0026lt; \u0026#34;invoke after: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 输出结果：\ninvoke before: 10 incr before: 10 incr after: 11 invoke after: 11 分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int\u0026amp; 才为引用传递，如果是用 int 的话还是值传递哦！\n1.5 为什么Java不引入引用传递 # 引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？\n注意：以下为个人观点看法，并非来自于 Java 官方：\n出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。 Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。 1.6 总结 # Java 中将实参传递给方法（或函数）的方式是 值传递：\n如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。 ","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741275961641-java-%E5%80%BC%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/","section":"Posts","summary":"","title":"java 值传递详解","type":"posts"},{"content":" Java序列化详解 # 1.1 序列化和反序列化 # 在计算机网络中，==序列化（Serialization）和反序列化（Deserialization）是指将数据结构或对象转换成可传输或存储的格式，以及从该格式还原成原始数据结构或对象的过程。==序列化是为了在网络中传输数据或将数据存储到磁盘等介质时，能够方便地将数据转换成字节流。反序列化则是将接收到的字节流还原成原始的数据结构或对象。\nJava的序列化过程就是指将Java对象转换为字节流的过程，可以将这些字节流保存到文件中或通过网络传输。 序列化的主要目的是 实现对象的持久化存储和传输，让对象可以在不同的计算机或不同的时间点被重建和使用。通过序列化，可以将对象的状态以字节的形式保存下来，并且在需要的时候进行恢复，从而实现了对象的跨平台传输和持久化存储。\n简单来说：\n序列化：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式 反序列化：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程 对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。\n序列化和反序列化常见应用场景：\n对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 维基百科是如是介绍序列化的：\n序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。\n综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。\nhttps://www.corejavaguru.com/java/serialization/interview-questions-1\n序列化协议对应于 TCP/IP 4 层模型的哪一层？\n我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？\n应用层 传输层 网络层 网络接口层 如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？\n因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。\n1.2 初始协议 # **在网络通信中，通信双方需要遵循一定的协议来确保正确、有效地进行数据交换。协议定义了通信的规则、格式以及消息的含义。**协议可以包括序列化和反序列化的规范，以确保数据在传输过程中能够正确地被解析。\n例如，常见的网络协议如HTTP、TCP、UDP等都规定了数据传输的格式和交互方式。对于数据的序列化和反序列化，有时候也需要使用特定的协议，例如JSON、XML、Protocol Buffers等。\n**初识协议是指对于通信过程中双方之间要遵循的规定、约定或规则。**这些规定定义了通信的格式、数据交换方式、消息的含义等，确保通信的双方能够理解和正确地处理彼此发送和接收的信息。协议在计算机网络、分布式系统、通信领域等都起到了关键的作用。\n协议可以分为多种类型，其中两个主要的类别是通信协议和传输协议。\n通信协议：\n**通信协议定义了通信双方之间的交流规则，包括消息的格式、语法、语义和同步方式。**一些常见的通信协议包括：\nHTTP（Hypertext Transfer Protocol）： 用于在Web浏览器和Web服务器之间传递信息，基于请求-响应模型。\nFTP（File Transfer Protocol）： 用于在客户端和服务器之间传输文件。\nSMTP（Simple Mail Transfer Protocol）： 用于在邮件客户端和邮件服务器之间传输电子邮件。\nDNS（Domain Name System）： 用于将域名映射到IP地址。\n传输协议：\n**传输协议定义了数据在网络中的传输方式，**包括数据的分段、重组、错误处理等。两个常见的传输协议是：\nTCP（Transmission Control Protocol）： 提供可靠的、面向连接的通信。TCP保证数据的可靠性，确保数据按照正确的顺序到达目的地。\nUDP（User Datagram Protocol）： 提供不可靠的、无连接的通信。UDP不保证数据的可靠性，但通常速度更快。\n序列化协议:\n在分布式系统中，**序列化协议定义了数据在网络上传输时的格式，以及如何将数据结构转换为字节流，以便在网络上传输。**一些常见的序列化协议包括：\nJSON（JavaScript Object Notation）： 一种轻量级的数据交换格式，易于阅读和编写，但性能较差。\nXML（eXtensible Markup Language）： 一种可扩展的标记语言，常用于表示结构化数据，易于阅读和编写，但性能较差。\nProtocol Buffers（protobuf）： 由Google开发的二进制序列化协议，具有高效的编码和解码速度。\n了解和遵循协议对于确保系统之间的正确通信和数据交换至关重要。协议的设计考虑到了性能、可扩展性、可读性等方面的因素，因此在设计和开发过程中需要谨慎选择和遵循适当的协议。\nJDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。\n1.2.1 JDK自带的序列化方式 # JDK 自带的序列化，只需实现 java.io.Serializable(/ˈsɪərɪəlaɪzəbl/)接口即可。\n@AllArgsConstructor @NoArgsConstructor @Getter @Builder @ToString public class RpcRequest implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private String requestId; private String interfaceName; private String methodName; private Object[] parameters; private Class\u0026lt;?\u0026gt;[] paramTypes; private RpcMessageTypeEnum rpcMessageTypeEnum; } 所有的非静态、非瞬态的字段都可以被序列化。 使用Java的序列化机制，可以通过ObjectOutputStream将对象转换为字节流并写入文件或网络流中。反之，通过ObjectInputStream可以从字节流中读取数据并还原为对象。\nserialVersionUID 有什么用？\n序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。\nserialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？\nstatic 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。\n🐛 修正（参见：issue#2174）：static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，serialVersionUID 是一个特例，serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出 InvalidClassException，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。\n官方说明如下：\nA serializable class can declare its own serialVersionUID explicitly by declaring a field named \u0026quot;serialVersionUID\u0026quot; that must be static, final, and of type long;\n如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 \u0026quot;serialVersionUID\u0026quot; 。\n也就是说，serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。\n如果有些字段不想进行序列化怎么办？\n对于不想进行序列化的变量，可以使用 transient (/ˈtrænziənt/)关键字修饰。\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。\n关于 transient 还有几点注意：\ntransient 只能修饰变量，不能修饰类和方法。 transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。 static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。 为什么不推荐使用 JDK 自带的序列化？\n我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：\n不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：应用安全:JAVA 反序列化漏洞之殇 - Cryin、Java 反序列化安全漏洞怎么回事? - Monica。 1.2.1.1 ObjectOutputStream类 # java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n构造方法：\npublic ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。\n序列化操作：\n一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1.2.1.2 ObjectInputStream类 # ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n构造方法\npublic ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。\n反序列化操作1\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\npublic final Object readObject () : 读取一个对象。 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n反序列化操作2\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。**发生这个异常的原因如下：\n该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n1.2.2 Kryo # Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。\n另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。\nguide-rpc-framework 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：\n/** * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language * * @author shuang.kou * @createTime 2020年05月13日 19:29:00 */ @Slf4j public class KryoSerializer implements Serializer { /** * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects */ private final ThreadLocal\u0026lt;Kryo\u0026gt; kryoThreadLocal = ThreadLocal.withInitial(() -\u0026gt; { Kryo kryo = new Kryo(); kryo.register(RpcResponse.class); kryo.register(RpcRequest.class); return kryo; }); @Override public byte[] serialize(Object obj) { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream)) { Kryo kryo = kryoThreadLocal.get(); // Object-\u0026gt;byte:将对象序列化为byte数组 kryo.writeObject(output, obj); kryoThreadLocal.remove(); return output.toBytes(); } catch (Exception e) { throw new SerializeException(\u0026#34;Serialization failed\u0026#34;); } } @Override public \u0026lt;T\u0026gt; T deserialize(byte[] bytes, Class\u0026lt;T\u0026gt; clazz) { try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); Input input = new Input(byteArrayInputStream)) { Kryo kryo = kryoThreadLocal.get(); // byte-\u0026gt;Object:从byte数组中反序列化出对象 Object o = kryo.readObject(input, clazz); kryoThreadLocal.remove(); return clazz.cast(o); } catch (Exception e) { throw new SerializeException(\u0026#34;Deserialization failed\u0026#34;); } } } GitHub 地址：https://github.com/EsotericSoftware/kryo 。\n1.2.3 Protobuf # Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。\nProtobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言\n一个简单的 proto 文件如下：\n// protobuf的版本 syntax = \u0026#34;proto3\u0026#34;; // SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct message Person { //string类型字段 string name = 1; // int 类型字段 int32 age = 2; } GitHub 地址：https://github.com/protocolbuffers/protobuf。\n1.2.4 ProtoStuff # 由于 Protobuf 的易用性较差，它的哥哥 Protostuff 诞生了。\nprotostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。\nGitHub 地址：https://github.com/protostuff/protostuff。\n1.2.5 Hessian # Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。\nDubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。\n1.2.6 总结 # Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/serialization/）。\n像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。\n除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。\n","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741276121143-java-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/","section":"Posts","summary":"","title":"java 序列化详解","type":"posts"},{"content":"an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\n","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741278579892-java-%E9%9B%86%E5%90%88/","section":"Posts","summary":"","title":"java 集合","type":"posts"},{"content":"an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\n","date":"6 March 2025","externalUrl":null,"permalink":"/posts/1741229251595-new-article/","section":"Posts","summary":"","title":"new-article","type":"posts"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"6 March 2025","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","section":"Tags","summary":"","title":"基础总结","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]